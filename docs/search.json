[{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Introduction to ridigbio","text":"First, must install ridigbio package. new R R studio, please refer QUBES module get started (Introduction R Biodiversity Data, doi:[10.25334/84FC-TE88](doi.org/10.25334/84FC-TE88)). lastest version R package can installed via CRAN. downloading records, must load ridigbio package.","code":"install.packages(\"ridigbio\") library(ridigbio)"},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"download-records","dir":"Articles","previous_headings":"","what":"Download Records","title":"Introduction to ridigbio","text":"download records Search API, use function idig_search_records(). rq, record query, indicates want download records scientificname equal Galax urceolata. fields specified, default columns include following:","code":"galax_records <- idig_search_records(rq=list(scientificname=\"Galax urceolata\")) colnames(galax_records) ##  [1] \"uuid\"               \"occurrenceid\"       \"catalognumber\"      ##  [4] \"family\"             \"genus\"              \"scientificname\"     ##  [7] \"country\"            \"stateprovince\"      \"geopoint.lon\"       ## [10] \"geopoint.lat\"       \"data.dwc:eventDate\" \"data.dwc:year\"      ## [13] \"data.dwc:month\"     \"data.dwc:day\"       \"collector\"          ## [16] \"recordset\""},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"more-ways-to-search","dir":"Articles","previous_headings":"Download Records","what":"More ways to search","title":"Introduction to ridigbio","text":"addition scientificname, record query may based many fields. example, can search members familyDiapensiaceae: want read points family within extent? Hint: Use iDigBio portal determine bounding box region interest. bounding box delimits geographic extent. Search using input just made","code":"diapensiaceae_records <- idig_search_records(rq=list(family=\"Diapensiaceae\"), limit=1000) rq_input <- list(\"scientificname\"=list(\"type\"=\"exists\"),                  \"family\"=\"Diapensiaceae\",                   geopoint=list(                    type=\"geo_bounding_box\",                    top_left=list(lon = -98.16, lat = 48.92),                    bottom_right=list(lon = -64.02, lat = 23.06)                    )                  ) diapensiaceae_records_USA <- idig_search_records(rq_input, limit=1000)"},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"download-media-records","dir":"Articles","previous_headings":"","what":"Download Media Records","title":"Introduction to ridigbio","text":"download media records Media API, use function idig_search_media(). rq, record query, indicates want download records scientificname equal Galax urceolata. fields specified, default columns include following:","code":"galax_media <- idig_search_media(rq=list(scientificname=\"Galax urceolata\")) colnames(galax_media) ##  [1] \"accessuri\"      \"datemodified\"   \"dqs\"            \"etag\"           ##  [5] \"flags\"          \"format\"         \"hasSpecimen\"    \"licenselogourl\" ##  [9] \"mediatype\"      \"modified\"       \"recordids\"      \"records\"        ## [13] \"recordset\"      \"rights\"         \"tag\"            \"type\"           ## [17] \"uuid\"           \"version\"        \"webstatement\"   \"xpixels\"        ## [21] \"ypixels\""},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"more-ways-to-search-1","dir":"Articles","previous_headings":"","what":"More ways to search","title":"Introduction to ridigbio","text":"media search retained 339 rows, however observations information accessuri field. obtain records acessuri, indicate want records data.ac:accessURI exist, setting mq, media query, followed: Now 325 observations accessuri!","code":"galax_media2 <- idig_search_media(rq=list(scientificname=\"Galax urceolata\"),                                   mq=list(\"data.ac:accessURI\"=list(\"type\"=\"exists\")))"},{"path":"http://idigbio.github.io/ridigbio/articles/Demoridigbio.html","id":"write-a-query-to-search-for-specimens-using-idig_search_records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimens using idig_search_records","title":"Demo of ridigbio","text":"use interface like iDigBio Portal, already writing query search specimens. new coding, can helpful begin figuring query user-friendly interface Portal, translating code R understand want search . One hardest parts using ridigbio search specimen records know field want search named. iDigBio API provides list field names , need reference sources, like documentation Darwin Core standard, understand kind information fields typically contain. matsumura palmer prince; j. . berly; o. l. cartwright stevenson powell jr. rosenkrans hyams walker hill, h. douglass feng henry young jones godfrey prince hermann kao gray hall michaux warter dunlop hill, h. douglass boyaton godfrey hatusima freeman tschonoski kao bossart midorikawa prince, j. . berly, o. l. cartwright batchelor prince; j. . berly; o. l. cartwright gray, c. s. sargent, j. h. redfield & w. m. canby hyams prince suzuki oosting hyams griggs prince rosenkrans prince, j. . berly & o. l. cartwright house darling davies tamura boynton crandall boynton hyams takamine amano moore prince; j. . berly; o. l. cartwright walker cole krebs togashi & y. tateishi boynton davies davis prince; j. . berly & o. l. cartwright kubo, m. togasi & t. matsuoka averyanov&#124;p.k. lôc&#124;n.t. vinh&#124;. averyanova crayton boynton boynton hill barnes kral keng powell, jr. hill rosenkrans rosenkrans tschonoski kao barnes prince; j. . berly, o.l.cartwright powell, jr. walker, s. sonohara, s. tawada & t. amano prince, j. berley & o. cartwright hyams rosenkrans powell, jr. jerabek hyams hill latham mullens perkins harris prince","code":"# Let's start with a simple search introducing the primary arguments for the # function `idig_search_records` records_1A <- idig_search_records(   # `rq` is where you adjust your record query   rq = list(genus = \"shortia\"),   # `fields` is where you adjust what fields you want returned by the API   fields = c(\"uuid\",              \"family\",              \"genus\",              \"specificepithet\",              \"scientificname\",              \"stateprovince\"),   # `limit` is where you can set a limit on the number of records to return in   # order to speed up your query; max is 100000   limit = 10,   # `sort` is where you can specify fields for sorting   sort = c(\"stateprovince\",            \"scientificname\"))  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_1A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # Now let's repeat the same search but remove all arguments other than `rq` to # see what the defaults for the other arguments look like records_1B <- idig_search_records(   rq = list(genus = \"shortia\"))  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_1B) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # In the example above, we are only using one parameter in `rq` to define our # query, but now let's search by multiple parameters records_2A <- idig_search_records(   rq = list(basisofrecord = \"fossilspecimen\",             # Use `type = \"exists\"` to search for rows where there is a value             # present in this field; the inverse of this is `type = \"missing\"`             geopoint = list(type = \"exists\")),   limit = 10)  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_2A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # What if we wanted to see more fields than the default provides? Using the same # search as above, we can retrieve all indexed fields with `fields = \"all\"` records_2B <- idig_search_records(   rq = list(basisofrecord = \"fossilspecimen\",           geopoint = list(type=\"exists\")),   fields = \"all\",   limit = 10)  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_2B) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # But wait, there are even more fields available than just those we retrieved # in the query above! Using the same search, we can choose exactly what fields # to retrieve from indexed and raw data if we call the fields out by name in # the `fields` argument; raw data fields are prefaced by \"data.dwc:\" and use  # camelCase in their naming convention (vs. lowercase for iDigBio fields) records_2C <- idig_search_records(   rq = list(basisofrecord = \"fossilspecimen\",           geopoint = list(type=\"exists\")),   # Here is where we are explicitly asking for specific fields   fields = c(\"uuid\",              \"recordset\",              \"institutioncode\", \"data.dwc:institutionCode\",              \"country\", \"data.dwc:country\",              \"countrycode\", \"data.dwc:countryCode\",              \"stateprovince\", \"data.dwc:stateProvince\",              \"locality\", \"data.dwc:locality\",              \"geopoint\", \"data.dwc:decimalLongitude\", \"data.dwc:decimalLatitude\"),   limit = 10)  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_2C) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # You may be curious what the difference is between indexed and raw data such as # that we saw in the search above. Indexed data has been altered by iDigBio # (often in an attempt to standardize and/or correct values), and raw data is # what was provided to iDigBio by the data provider, i.e. the natural history # collection. Here we will do a new search on a data quality flag to view # differences between indexed and raw data records_3A <- idig_search_records(   # Data quality flags are a way for iDigBio to communicate how data was altered   # during its quality control process, i.e. how the indexed and raw data differ   rq = list(flags = \"rev_geocode_lat_sign\"),   fields = c(\"uuid\",              \"institutioncode\", \"data.dwc:institutionCode\",              \"country\", \"data.dwc:country\",              \"countrycode\", \"data.dwc:countryCode\",              \"stateprovince\", \"data.dwc:stateProvince\",              \"locality\", \"data.dwc:locality\",              \"geopoint\", \"data.dwc:decimalLongitude\", \"data.dwc:decimalLatitude\"),   limit = 10)  # Let's format our results to be more readable by renaming and reordering columns records_3A <- records_3A %>%    rename_at(vars(starts_with(\"data.dwc:\")),             ~str_replace(., \"data.dwc:\", \"raw_\")) %>%    select(uuid,          indexed_decimalLatitude = geopoint.lat,          raw_decimalLatitude,          indexed_decimalLongitude = geopoint.lon,          raw_decimalLongitude,          everything())  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_3A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\")"},{"path":"http://idigbio.github.io/ridigbio/articles/Demoridigbio.html","id":"quickly-get-a-count-of-how-many-specimens-match-a-query-using-idig_count_records","dir":"Articles","previous_headings":"","what":"Quickly get a count of how many specimens match a query using idig_count_records","title":"Demo of ridigbio","text":"Sometimes number records matching query important purposes records , instance trying calculate many fossil specimens iDigBio geographic coordinate data. can use query format idig_count_records can idig_search_records answer question “many records query return?” quickly. function also useful suspect query might return 100,000 records, limit single iteration idig_search_records.","code":"# Let's test out a search using parameters we know would retrieve many records count_1A <- idig_count_records(   rq = list(basisofrecord = \"fossilspecimen\",           geopoint = list(type=\"exists\")))  # We can reformat our result to be more readable count_1A <- format(count_1A, big.mark = \",\")  # This number shows how many records in iDigBio have a value of \"fossilspecimen\" # as well as geographic coordinate data count_1A ## [1] \"3,205,189\""},{"path":"http://idigbio.github.io/ridigbio/articles/Demoridigbio.html","id":"discover-the-most-frequent-values-for-a-field-using-idig_top_records","dir":"Articles","previous_headings":"","what":"Discover the most frequent values for a field using idig_top_records","title":"Demo of ridigbio","text":"trouble understanding kind information lives particular field, may useful look common values exist field. idig_top_records function can show . , function uses basic rq argument define query.","code":"# Let's go back to our first simple search and see what the top values are for # `scientificname` where the genus is \"shortia\" top_1A <- idig_top_records(   # `rq` is where you adjust your record query   rq = list(genus = \"shortia\"),   # `top_fields` is where you adjust what fields you want to see summarized   top_fields = \"scientificname\",   # `count` is where you can set a limit on the number of top values to return   # in order to speed up your query; max is 1000   count = 10)  # We need to convert our results from a nested list into a more readable format top_1A <- as_tibble(top_1A$scientificname) %>%    pivot_longer(everything(), names_to = \"scientificname\", values_to = \"count\")  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(top_1A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\")"},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"search-api-fields","dir":"Articles","previous_headings":"","what":"Search API Fields","title":"Fields in ridigbio","text":"identify raw, verbatim, fields available Search API, can run following: addition fields provided data providers, Search API contains fields indexed potentially modified iDigBio. identify indexed fields available Search API, can run following: Note, fields lists different. However, contain similar information. example, scientificName can found raw index fields.","code":"record_fields <- idig_meta_fields(type = \"records\", subset = \"raw\") rfall <- data.frame(matrix(ncol = 3, nrow = 0))  for(i in 1:length(record_fields)){   if(length(record_fields[[i]]) == 2){     rf <- data.frame(matrix(ncol = 3, nrow = 0))     rf[1, 1] <-  names(record_fields[i])     rf[1, 2] <-  (record_fields[[i]])$type     rf[1, 3] <-  (record_fields[[i]])$fieldName     rfall <- rbind(rfall, rf)   }else{    sub <- record_fields[[i]]     for(j in 1:length(sub)){       rf <- data.frame(matrix(ncol = 3, nrow = 0))       rf[1, 1] <-  names(sub[j])       rf[1, 2] <-  (sub[[j]])$type       rf[1, 3] <-  (sub[[j]])$fieldName       rfall <- rbind(rfall, rf)      }   } } colnames(rfall) <- c(\"name\", \"type\", \"fieldName\") nrow(rfall) ## [1] 317 record_fields_index <- idig_meta_fields(type = \"records\", subset = \"indexed\") rfalli <- data.frame(matrix(ncol = 3, nrow = 0))    for(i in 1:length(record_fields_index)){     if(length(record_fields_index[[i]]) == 2){       rf <- data.frame(matrix(ncol = 3, nrow = 0))       rf[1, 1] <-  names(record_fields_index[i])       rf[1, 2] <-  (record_fields_index[[i]])$type       rf[1, 3] <-  (record_fields_index[[i]])$fieldName       rfalli <- rbind(rfalli, rf)     }else{      sub <- record_fields_index[[i]]       for(j in 1:length(sub)){         rf <- data.frame(matrix(ncol = 3, nrow = 0))         rf[1, 1] <-  names(sub[j])         rf[1, 2] <-  (sub[[j]])$type         rf[1, 3] <-  (sub[[j]])$fieldName         rfalli <- rbind(rfalli, rf)        }     }   } colnames(rfalli) <- c(\"name\", \"type\", \"fieldName\") nrow(rfalli) ## [1] 81 setequal(rfall, rfalli) ## [1] FALSE rfall[238,] ##                   name   type               fieldName ## 238 dwc:samplingEffort string data.dwc:samplingEffort rfalli[69,] ##              name   type      fieldName ## 69 scientificname string scientificname"},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"retain-records-with-these-fields","dir":"Articles","previous_headings":"Search API Fields","what":"Retain records with these fields","title":"Fields in ridigbio","text":"obtain records fields idig_search_records() function, simply list fields arugument equal fields.","code":"out <- idig_search_records(rq=list(scientificname=\"Galax urceolata\"),                             fields = rfall$fieldName[1:88])"},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"media-record-api-fields","dir":"Articles","previous_headings":"","what":"Media Record API Fields","title":"Fields in ridigbio","text":"identify raw, verbatim, fields available Media Record API, can run following: Like Search API, Media Record API fields indexed potentially modified iDigBio. identify indexed fields available Media Record API, can run following: Note, index fields associated Media Record API returned default idig_search_media() function.","code":"media_fields <- idig_meta_fields(type = \"media\", subset = \"raw\") mfall <- data.frame(matrix(ncol = 3, nrow = 0))  for(i in 1:length(media_fields)){     if(length(media_fields[[i]]) == 2){       mf <- data.frame(matrix(ncol = 3, nrow = 0))       mf[1, 1] <-  names(media_fields[i])       mf[1, 2] <-  (media_fields[[i]])$type       mf[1, 3] <-  (media_fields[[i]])$fieldName       mfall <- rbind(mfall, mf)     }else{      sub <- media_fields[[i]]       for(j in 1:length(sub)){         mf <- data.frame(matrix(ncol = 3, nrow = 0))         mf[1, 1] <-  names(sub[j])         mf[1, 2] <-  (sub[[j]])$type         mf[1, 3] <-  (sub[[j]])$fieldName         mfall <- rbind(mfall, mf)        }     }   } colnames(mfall) <- c(\"name\", \"type\", \"fieldName\") nrow(mfall) ## [1] 150 media_fields_index <- idig_meta_fields(type = \"media\", subset = \"indexed\") mfalli <- data.frame(matrix(ncol = 3, nrow = 0))  for(i in 1:length(media_fields_index)){     if(length(media_fields_index[[i]]) == 2){       mf <- data.frame(matrix(ncol = 3, nrow = 0))       mf[1, 1] <-  names(media_fields_index[i])       mf[1, 2] <-  (media_fields_index[[i]])$type       mf[1, 3] <-  (media_fields_index[[i]])$fieldName       mfalli <- rbind(mfalli, mf)     }else{      sub <- media_fields_index[[i]]       for(j in 1:length(sub)){         mf <- data.frame(matrix(ncol = 3, nrow = 0))         mf[1, 1] <-  names(sub[j])         mf[1, 2] <-  (sub[[j]])$type         mf[1, 3] <-  (sub[[j]])$fieldName         mfalli <- rbind(mfalli, mf)        }     }   } colnames(mfalli) <- c(\"name\", \"type\", \"fieldName\") nrow(mfalli) ## [1] 21 mfalli$name ##  [1] \"accessuri\"      \"datemodified\"   \"dqs\"            \"etag\"           ##  [5] \"flags\"          \"format\"         \"hasSpecimen\"    \"licenselogourl\" ##  [9] \"mediatype\"      \"modified\"       \"recordids\"      \"records\"        ## [13] \"recordset\"      \"rights\"         \"tag\"            \"type\"           ## [17] \"uuid\"           \"version\"        \"webstatement\"   \"xpixels\"        ## [21] \"ypixels\""},{"path":"http://idigbio.github.io/ridigbio/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Francois Michonneau. Author, copyright holder.            Original Author Matthew Collins. Author.            Original Author Scott Chamberlain. Contributor. Kevin Love. Contributor. Hem Nalini Morzaria-Luna. Contributor. Michelle L. Gaynor. Contributor. Jesse Bennett. Maintainer.            Maintainer","code":""},{"path":"http://idigbio.github.io/ridigbio/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Michonneau F, Collins M (2024). ridigbio: Interface iDigBio Data API. R package version 0.3.8, https://CRAN.R-project.org/package=ridigbio.","code":"@Manual{,   title = {ridigbio: Interface to the iDigBio Data API},   author = {Francois Michonneau and Matthew Collins},   year = {2024},   note = {R package version 0.3.8},   url = {https://CRAN.R-project.org/package=ridigbio}, }"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"installation","dir":"","previous_headings":"","what":"Interface to the iDigBio Data API","title":"Interface to the iDigBio Data API","text":"automatically install package CRAN mirror one configured: R says package unavailable, may set CRAN mirror. can : R says binary package available, version R may old. Please review versions R CRAN built packages CRAN ridigbio package page. can download source package install manually package built version R. may also need install dependencies. Linux, may encounter error installation process libcurl installed. method installing libcurl vary distributions, Ubuntu can install latest version via:","code":"install.packages(\"ridigbio\") chooseCRANmirror() install.packages(\"ridigbio\", type=\"source\") sudo apt install libcurl4"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"basic-usage","dir":"","previous_headings":"","what":"Basic usage","title":"Interface to the iDigBio Data API","text":"","code":"library(\"ridigbio\") idig_search_records(rq=list(genus=\"galax\")) idig_search_records(rq=list(family=\"holothuriidae\"), limit=1000)"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"recent-updates","dir":"","previous_headings":"","what":"Recent updates","title":"Interface to the iDigBio Data API","text":"Default fields returned users updated return research-grade fields. Previously, returned datecollected field default, recommend used scientific research. datecollected? field created data ingestion process. data provider provide full date Darwin Core eventDate field, complete value missing parts (.e., month /day) randomly generated thus may lack real meaning. generated dates difficult detect, randomly distributed. currently working modify ingestion pipeline avoid randomly generating dates. However, dates remain issue across biodiversity aggregators solution clear (see GBIF example). Please advised fields date format. Instead, dates text strings. many ways convert dates, example, see gatoRs remove_duplicate function ridigbio proposed solution . Additional documentation added streamline data use.","code":""},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Interface to the iDigBio Data API","text":"MIT","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":null,"dir":"Reference","previous_headings":"","what":"Build fields and fields_exclude for queries. — build_field_lists","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"Given desired fields returned, intelligently add exclusion data array warranted handle \"\" keyword. without setting fields fields_exclude due fact API return wrong results passed. still posssible user deliberately sets . exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"","code":"build_field_lists(fields, type)"},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"fields character vector fields user wants returned type type records get fields ","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"list list fields key df fields query key parameters merged query sent","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/dot-onAttach.html","id":null,"dir":"Reference","previous_headings":"","what":"onAttach — .onAttach","title":"onAttach — .onAttach","text":"Display startup message","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/dot-onAttach.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"onAttach — .onAttach","text":"","code":".onAttach(...)"},{"path":"http://idigbio.github.io/ridigbio/reference/dot-onAttach.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"onAttach — .onAttach","text":"... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":null,"dir":"Reference","previous_headings":"","what":"internal GET request — idig_GET","title":"internal GET request — idig_GET","text":"Internal function GET requests.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"internal GET request — idig_GET","text":"","code":"idig_GET(path, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"internal GET request — idig_GET","text":"path endpoint ... additional arguments passed httr::GET","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"internal GET request — idig_GET","text":"request (list)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"internal GET request — idig_GET","text":"Generates GET request performs checks returned. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"internal GET request — idig_GET","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":null,"dir":"Reference","previous_headings":"","what":"internal POST request — idig_POST","title":"internal POST request — idig_POST","text":"Internal function POST requests.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"internal POST request — idig_POST","text":"","code":"idig_POST(path, body, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"internal POST request — idig_POST","text":"path endpoint body list parameters endpoint ... additional arguments passed httr::POST","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"internal POST request — idig_POST","text":"request (list)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"internal POST request — idig_POST","text":"Generates POST request performs checks returned. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"internal POST request — idig_POST","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":null,"dir":"Reference","previous_headings":"","what":"Attribution dataframe of iDigBio records query — idig_build_attrib","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"Function build attribution dataframe query iDigBio API","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"","code":"idig_build_attrib(dat)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"dat dataframe generated idig_search method","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"data frame","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"function differs attribution metadata attached dataframe returned idig_search_* methods. summarizes record sets used records dataframe, record sets records match query sent iDigBio. useful part records query downloaded, example limit offset parameters. Exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"Kevin Love","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":null,"dir":"Reference","previous_headings":"","what":"check HTTP code — idig_check","title":"check HTTP code — idig_check","text":"Checks HTTP error codes JSON errors.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check HTTP code — idig_check","text":"","code":"idig_check(req)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check HTTP code — idig_check","text":"req returned request","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check HTTP code — idig_check","text":"nothing. Stops HTTP code >= 400","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"check HTTP code — idig_check","text":"Part 1 error checking process. part handles HTTP error codes calls part 2 handles JSON errors responses. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"check HTTP code — idig_check","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Check is the request returned an error. — idig_check_error","title":"Check is the request returned an error. — idig_check_error","text":"Checks error messages can returned API JSON.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check is the request returned an error. — idig_check_error","text":"","code":"idig_check_error(req)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check is the request returned an error. — idig_check_error","text":"req returned request","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check is the request returned an error. — idig_check_error","text":"nothing. Stops request contains error.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check is the request returned an error. — idig_check_error","text":"Part 2 error checking process. Checks JSON response error messages stops found. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check is the request returned an error. — idig_check_error","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":null,"dir":"Reference","previous_headings":"","what":"Count media endpoint — idig_count_media","title":"Count media endpoint — idig_count_media","text":"Count media records matching query.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count media endpoint — idig_count_media","text":"","code":"idig_count_media(rq = FALSE, mq = FALSE, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count media endpoint — idig_count_media","text":"rq iDigBio record query nested list format mq iDigBio media query nested list format ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count media endpoint — idig_count_media","text":"count media records matching query(s)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count media endpoint — idig_count_media","text":"Quickly return count media records matching query(s) provided.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count media endpoint — idig_count_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":null,"dir":"Reference","previous_headings":"","what":"Count record endpoint — idig_count_records","title":"Count record endpoint — idig_count_records","text":"Count specimen records matching query.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count record endpoint — idig_count_records","text":"","code":"idig_count_records(rq = FALSE, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count record endpoint — idig_count_records","text":"rq iDigBio record query nested list format ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count record endpoint — idig_count_records","text":"count specimen records matching query(s)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count record endpoint — idig_count_records","text":"Quickly return count specimen records matching query(s) provided.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count record endpoint — idig_count_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"meta fields endpoint — idig_meta_fields","title":"meta fields endpoint — idig_meta_fields","text":"List fields iDigBio.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"meta fields endpoint — idig_meta_fields","text":"","code":"idig_meta_fields(type = \"records\", subset = FALSE, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"meta fields endpoint — idig_meta_fields","text":"type string type fields return, defaults \"records\" subset set fields return, \"indexed\", \"raw\", unset ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"meta fields endpoint — idig_meta_fields","text":"list fields requested type","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"meta fields endpoint — idig_meta_fields","text":"Return list media specimen fields contained iDigBio.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"meta fields endpoint — idig_meta_fields","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"parse successfully returned request — idig_parse","title":"parse successfully returned request — idig_parse","text":"Parses output successful query return list.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"parse successfully returned request — idig_parse","text":"","code":"idig_parse(req)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"parse successfully returned request — idig_parse","text":"req returned request","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"parse successfully returned request — idig_parse","text":"list","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"parse successfully returned request — idig_parse","text":"exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"parse successfully returned request — idig_parse","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic searching of iDigBio records — idig_search","title":"Basic searching of iDigBio records — idig_search","text":"Base function query iDigBio API","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic searching of iDigBio records — idig_search","text":"","code":"idig_search(   type = \"records\",   mq = FALSE,   rq = FALSE,   fields = FALSE,   max_items = 1e+05,   limit = 0,   offset = 0,   sort = FALSE,   ... )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic searching of iDigBio records — idig_search","text":"type string type records query, defaults \"records\" mq iDigBio media query nested list format rq iDigBio record query nested list format fields vector fields contained data.frame max_items CURRENTLY IGNORED, SEE ISSUE #33 maximum number results allowed retrieved (fail-safe) limit maximum number results returned offset number results skip returning results sort vector fields use sorting, UUID always appended make paging safe ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic searching of iDigBio records — idig_search","text":"data frame","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basic searching of iDigBio records — idig_search","text":"function wrapped media specimen record searches. Please consider using idig_search_media idig_search_records instead supply nice defaults function depending type records desired. Fuller documentation parameters idig_search_records function's help. Exported facilitate wrapping package packages.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Basic searching of iDigBio records — idig_search","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic searching of iDigBio records — idig_search","text":"","code":"if (FALSE) { # Ten media records related to genus Acer specimens idig_search(type=\"media\", rq=list(genus=\"acer\"), limit=10) }"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":null,"dir":"Reference","previous_headings":"","what":"Searching of iDigBio media records — idig_search_media","title":"Searching of iDigBio media records — idig_search_media","text":"Function query iDigBio API media records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Searching of iDigBio media records — idig_search_media","text":"","code":"idig_search_media(   mq = FALSE,   rq = FALSE,   fields = FALSE,   max_items = 1e+05,   limit = 0,   offset = 0,   sort = FALSE,   ... )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Searching of iDigBio media records — idig_search_media","text":"mq iDigBio media query nested list format rq iDigBio record query nested list format fields vector fields contained data.frame, defaults \"\" indexed fields max_items maximum number results allowed retrieved (fail -safe) limit maximum number results returned offset number results skip returning results sort vector fields use sorting, UUID always appended make paging safe ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Searching of iDigBio media records — idig_search_media","text":"data frame fields requested following default fields:   * [accessuri](https://ac.tdwg.org/termlist/#ac_accessURI)   * datemodified: Date last modified, assigned iDigBio.   * dqs: Data quality score assigned iDigBio.   * etag: Tag assigned iDigBio.   * flags: Data quality flag assigned iDigBio.   * [format](http://purl.org/dc/terms/format)   * hasSpecimen: TRUE FALSE, indicates associated record media.   * [licenselogourl](https://ac.tdwg.org/termlist/#ac_licenseLogoURL)   * mediatype: Media object type.   * [modified](http://purl.org/dc/terms/modified)   * recordids: List UUID associated records.   * records: UUID associated record.   * recordset: Record set ID assigned iDigBio.   * [rights](http://purl.org/dc/terms/rights)   * [tag](http://rs.tdwg.org/ac/terms/tag)    * [type](http://purl.org/dc/terms/type)   * uuid: Unique identifier assigned iDigBio.   * version: Media record version assigned iDigBio.   * [webstatement](https://developer.adobe.com/xmp/docs/XMPNamespaces/xmpRights/)    * xpixels: defined EXIF, x dimension pixel.   * ypixels: defined EXIF,y dimension pixels.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Searching of iDigBio media records — idig_search_media","text":"Also see idig_search_records full examples parameters related searching iDigBio. Wraps idig_search provide defaults specific searching media records. Using function instead idig_search directly recommened. Record queries media queries objects allowed (rq mq parameters) media records returned match requirements . function defaults returning indexed media record fields.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Searching of iDigBio media records — idig_search_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Searching of iDigBio media records — idig_search_media","text":"","code":"if (FALSE) { # Searching for media using a query on related specimen information - first # 10 media records with image URIs related to a specimen in the genus Acer: df <- idig_search_media(rq=list(genus=\"acer\"),                         mq=list(\"data.ac:accessURI\"=list(\"type\"=\"exists\")),                         fields=c(\"uuid\",\"data.ac:accessURI\"), limit=10) }"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":null,"dir":"Reference","previous_headings":"","what":"Searching of iDigBio records — idig_search_records","title":"Searching of iDigBio records — idig_search_records","text":"Function query iDigBio API specimen records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Searching of iDigBio records — idig_search_records","text":"","code":"idig_search_records(   rq,   fields = FALSE,   max_items = 1e+05,   limit = 0,   offset = 0,   sort = FALSE,   ... )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Searching of iDigBio records — idig_search_records","text":"rq iDigBio record query nested list format fields vector fields contained data.frame, limited set returned default, use \"\" get indexed fields max_items maximum number results allowed retrieved (fail -safe) limit maximum number results returned offset number results skip returning results sort vector fields use sorting, UUID always appended make paging safe ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Searching of iDigBio records — idig_search_records","text":"data frame fields requested following default fields:   * UUID: Unique identifier assigned iDigBio.   * [occurrenceID](https://dwc.tdwg.org/list/#dwc_occurrenceID)   * [catalognumber](http://rs.tdwg.org/dwc/terms/catalogNumber)   * [family](http://rs.tdwg.org/dwc/terms/family) - may reassigned iDigBio   * [genus](https://dwc.tdwg.org/list/#dwc_genus) - may reassigned iDigBio   * [scientificname](http://rs.tdwg.org/dwc/terms/scientificName) - may reassigned iDigBio   * [country](http://rs.tdwg.org/dwc/terms/country) - may modified iDigBio   * [stateprovince](http://rs.tdwg.org/dwc/terms/stateProvince)   * geopoint   * [data.dwc:eventDate](https://dwc.tdwg.org/list/#dwc_eventDate)   * [data.dwc:year](https://dwc.tdwg.org/list/#dwc_year)   * [data.dwc:month](https://dwc.tdwg.org/list/#dwc_month)   * [data.dwc:day](https://dwc.tdwg.org/list/#dwc_day)   * collector   * recordset: Assigned iDigBio","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Searching of iDigBio records — idig_search_records","text":"Wraps idig_search provide defaults specific searching specimen records. Using function instead idig_search directly recommened. Queries need specified nested list structure serialize iDigBio query object's JSON expected iDigBio API: https://github.com/iDigBio/idigbio-search-api/wiki/Query-Format example, first sample query looks like JSON API documentation: rewrite R use rq parameter idig_search_records idig_search_media, look like : example complex JSON query nested structures: rewrite R use rq parameter, use nested calls list() function: See Examples section samples simpler complex queries. Please refer API documentation full functionality availible queries. matching results returned max_items cap (default 100,000). results wanted, higher max_items can passed option. API loads records 5,000 time using HTTP performance large sets data good. Expect result sets 50,000 records take tens minutes. can use idig_count_records idig_count_media functions find many records query return; fast. iDigBio API return 5,000 records time function automatically page results return . Limit offset availible manual paging results needed though max_items cap still applies. item count comes results header count actual records limit/offset window. Return data.frame containing requested fields (default fields). columns data frame untyped factors pre- built. Attribution metadata attached dataframe data.frame's attributes. (.e. attributes(df))","code":"{   \"scientificname\": {     \"type\": \"exists\"   },   \"family\": \"asteraceae\" } rq <- list(\"scientificname\"=list(\"type\"=\"exists\"),            \"family\"=\"asteraceae\"            ) {   \"geopoint\": {    \"type\": \"geo_bounding_box\",    \"top_left\": {      \"lat\": 19.23,      \"lon\": -130     },     \"bottom_right\": {       \"lat\": -45.1119,       \"lon\": 179.99999     }    }  } rq <- list(geopoint=list(                          type=\"geo_bounding_box\",                          top_left=list(lat=19.23, lon=-130),                          bottom_right=list(lat=-45.1119, lon= 179.99999)                         )            )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Searching of iDigBio records — idig_search_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Searching of iDigBio records — idig_search_records","text":"","code":"if (FALSE) { # Simple example of retriving records in a genus: idig_search_records(rq=list(genus=\"acer\"), limit=10)  # This complex query shows that booleans passed to the API are represented # as strings in R, fields used in the query don't have to be returned, and # the syntax for accessing raw data fields: idig_search_records(rq=list(\"hasImage\"=\"true\", genus=\"acer\"),             fields=c(\"uuid\", \"data.dwc:verbatimLatitude\"), limit=100)  # Searching inside a raw data field for a string, note that raw data fields # are searched as full text, indexed fields are search with exact matches:  idig_search_records(rq=list(\"data.dwc:dynamicProperties\"=\"parasite\"),             fields=c(\"uuid\", \"data.dwc:dynamicProperties\"), limit=100)  # Retriving a data.frame for use with MaxEnt. Notice geopoint is expanded # to two columns in the data.frame: gepoint.lat and geopoint.lon: df <- idig_search_records(rq=list(genus=\"acer\", geopoint=list(type=\"exists\")),           fields=c(\"uuid\", \"geopoint\"), limit=10) write.csv(df[c(\"uuid\", \"geopoint.lon\", \"geopoint.lat\")],           file=\"acer_occurrences.csv\", row.names=FALSE)  }"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":null,"dir":"Reference","previous_headings":"","what":"Top media endpoint — idig_top_media","title":"Top media endpoint — idig_top_media","text":"Top media records summaries.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Top media endpoint — idig_top_media","text":"","code":"idig_top_media(rq = FALSE, mq = FALSE, top_fields = FALSE, count = 0, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Top media endpoint — idig_top_media","text":"rq iDigBio record query nested list format mq iDigBio media query nested list format top_fields vector field names summarize count maximum number results return, capped 1000 ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Top media endpoint — idig_top_media","text":"nested list field values counts media records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Top media endpoint — idig_top_media","text":"Summarize count media records iDigBio according unique values fields passed. operates similarly SELECT DISTINCT count( field_name) query SQL. multiple fields passed, summaries nested eg fields=c(\"country\", \"genus\") result counting top 10 genera top 10 countries total 100 counts.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Top media endpoint — idig_top_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":null,"dir":"Reference","previous_headings":"","what":"Top records endpoint — idig_top_records","title":"Top records endpoint — idig_top_records","text":"Top specimen records summaries.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Top records endpoint — idig_top_records","text":"","code":"idig_top_records(rq = FALSE, top_fields = FALSE, count = 0, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Top records endpoint — idig_top_records","text":"rq iDigBio record query nested list format top_fields vector field names summarize count maximum number results return, capped 1000 ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Top records endpoint — idig_top_records","text":"nested list field values counts specimen records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Top records endpoint — idig_top_records","text":"Summarize count specimen records iDigBio according unique values fields passed. operates similarly SELECT DISTINCT count(field_name) query SQL. multiple fields passed, summaries nested eg fields=c(\"country\", \"genus\") result counting top 10 genera top 10 countries total 100 counts.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Top records endpoint — idig_top_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":null,"dir":"Reference","previous_headings":"","what":"base URL — idig_url","title":"base URL — idig_url","text":"Return base URL API calls.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"base URL — idig_url","text":"","code":"idig_url(dev = FALSE)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"base URL — idig_url","text":"dev beta version API used?","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"base URL — idig_url","text":"string URL","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"base URL — idig_url","text":"Defaults use beta URL. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"base URL — idig_url","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":null,"dir":"Reference","previous_headings":"","what":"validate fields — idig_validate","title":"validate fields — idig_validate","text":"Stub function validating parameters.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"validate fields — idig_validate","text":"","code":"idig_validate(inputs)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"validate fields — idig_validate","text":"inputs list inputs validate","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"validate fields — idig_validate","text":"boolean","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"validate fields — idig_validate","text":"Takes list inputs named validation rule eg \"number\":[2, 3] returns vector strings validation errors. vector 0 length, everything valid. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"validate fields — idig_validate","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":null,"dir":"Reference","previous_headings":"","what":"API version — idig_version","title":"API version — idig_version","text":"Return version number use API calls.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"API version — idig_version","text":"","code":"idig_version(version = \"v2\")"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"API version — idig_version","text":"version optional argument giving version API use","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"API version — idig_version","text":"string version use","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"API version — idig_version","text":"current default \"v2\". exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"API version — idig_version","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":null,"dir":"Reference","previous_headings":"","what":"view media endpoint — idig_view_media","title":"view media endpoint — idig_view_media","text":"View individual media records.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"view media endpoint — idig_view_media","text":"","code":"idig_view_media(uuid, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"view media endpoint — idig_view_media","text":"uuid uuid media record ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"view media endpoint — idig_view_media","text":"nested list data","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"view media endpoint — idig_view_media","text":"View information specific media record.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"view media endpoint — idig_view_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":null,"dir":"Reference","previous_headings":"","what":"view specimen endpoint — idig_view_records","title":"view specimen endpoint — idig_view_records","text":"View individual specimen records.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"view specimen endpoint — idig_view_records","text":"","code":"idig_view_records(uuid, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"view specimen endpoint — idig_view_records","text":"uuid uuid specimen record ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"view specimen endpoint — idig_view_records","text":"nested list data","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"view specimen endpoint — idig_view_records","text":"View information specific specimen record.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"view specimen endpoint — idig_view_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ridigbio: Interface to the iDigBio Data API — ridigbio-package","title":"ridigbio: Interface to the iDigBio Data API — ridigbio-package","text":"interface iDigBio's search API allows downloading specimen records. Searches returned data.frame. functions metadata end points return lists information. iDigBio US project focused digitizing serving museum specimen collections web. See https://www.idigbio.org information iDigBio.","code":""},{"path":[]},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ridigbio: Interface to the iDigBio Data API — ridigbio-package","text":"Maintainer: Jesse Bennett j3553@ufl.edu (Maintainer) Authors: Francois Michonneau francois.michonneau@gmail.com (Original Author) [copyright holder] Matthew Collins mcollins@acis.ufl.edu (Original Author) contributors: Scott Chamberlain myrmecocystus@gmail.com [contributor] Kevin Love klove@flmnh.ufl.edu [contributor] Hem Nalini Morzaria-Luna hemnalin.morzarialuna@noaa.gov [contributor] Michelle L. Gaynor michellegaynor@ufl.edu [contributor]","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve data from the iDigBio specimen data repository. — ridigbio","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"Retrieve data iDigBio specimen data repository.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"about","dir":"Reference","previous_headings":"","what":"About","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"ridigbio provides interface iDigBio data API described :  https://www.idigbio.org/wiki/index.php/IDigBio_API. package can retrieve specimen media records iDigBio data  repository. iDigBio portal https://portal.idigbio.org/ uses  API able retrieve information shown portal. iDigBio contains nearly 30 million data records museum specimens held United States institutions. also holds nearly 5 million images specimens.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"getting-started","dir":"Reference","previous_headings":"","what":"Getting Started","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"main function idig_search_records reviewing documenation first ?idig_search_records recommended.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"limitations","dir":"Reference","previous_headings":"","what":"Limitations","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"package yet provide interface mapping  download APIs.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"citing","dir":"Reference","previous_headings":"","what":"Citing","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"cite ridigbio package work, please use following format: Michonneau F, Collins M, Chamberlain SA (2016). ridigbio: interface iDigBio's search API allows downloading specimen records. R package version 0.3.8. https://github.com/iDigBio/ridigbio","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"Francois Michonneau francois.michonneau@gmail.com Matthew Collins mcollins@acis.ufl.edu","code":""}]
