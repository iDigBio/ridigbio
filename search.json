[{"path":"http://idigbio.github.io/ridigbio/articles/BadCoordinateID.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Identification of Suspicious Coordinates","text":"explore situation geographic coordinate data provider modified iDigBio data quality assurance process. See information iDigBio’s data quality flags. demo cover : Write query search specimens using idig_search_records Identify map suspicious coordinates","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/BadCoordinateID.html","id":"load-packages-","dir":"Articles","previous_headings":"","what":"Load Packages.","title":"Identification of Suspicious Coordinates","text":"","code":"install.packages('tidyverse',repos = \"http://cran.us.r-project.org\") ##  ## The downloaded binary packages are in ##  /var/folders/98/rnr3bm497gn395gzqtwk917w0000gn/T//RtmplmOU2K/downloaded_packages # Load core libraries; install these packages if you have not already library(ridigbio) library(tidyverse)  # Load library for making nice HTML output library(kableExtra)  # Load libraries for visualizing geographic data library(leaflet)"},{"path":"http://idigbio.github.io/ridigbio/articles/BadCoordinateID.html","id":"write-a-query-to-search-for-specimen-records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimen records","title":"Identification of Suspicious Coordinates","text":"First, let’s find specimen records data quality flag interested . using idig_search_records function ridigbio package. can learn function iDigBio API documentation ridigbio documentation. example, want start searching specimens flagged “rev_geocode_corrected.” query result data looks like:","code":"# Edit the fields (e.g. `flags`) and values (e.g. \"rev_geocode_corrected\") in # `list()` to adjust your query and the fields (e.g. `uuid`) in `fields` to # adjust the columns returned in your results df_flagCoord <- idig_search_records(rq = list(flags = \"rev_geocode_corrected\",                                               institutioncode = \"lacm\"),                     fields = c(\"uuid\",                                \"institutioncode\",                                \"collectioncode\",                                \"country\",                                \"data.dwc:country\",                                \"stateprovince\",                                \"county\",                                \"locality\",                                \"geopoint\",                                \"data.dwc:decimalLongitude\",                                \"data.dwc:decimalLatitude\",                                \"flags\"),                     limit = 100000) %>%    # Rename fields to more easily reflect their provenance (either from the   # data provider directly or modified by the data aggregator)   rename(provider_lon = `data.dwc:decimalLongitude`,          provider_lat = `data.dwc:decimalLatitude`,          provider_country = `data.dwc:country`,          aggregator_lon = `geopoint.lon`,          aggregator_lat = `geopoint.lat`,          aggregator_country = country,          aggregator_stateprovince = stateprovince,          aggregator_county = county,          aggregator_locality = locality) %>%    # Reorder columns for easier viewing   select(uuid, institutioncode, collectioncode, provider_lat, aggregator_lat,          provider_lon, aggregator_lon, provider_country, aggregator_country,          aggregator_stateprovince, aggregator_county, aggregator_locality,          flags)"},{"path":"http://idigbio.github.io/ridigbio/articles/BadCoordinateID.html","id":"visualize-suspicious-coordinates","dir":"Articles","previous_headings":"","what":"Visualize suspicious coordinates","title":"Identification of Suspicious Coordinates","text":"One example geographic coordinate data quality issue latitude/longitude reversed sign, e.g. data provider gave value latitude = “7.1789” meant latitude = “-7.1789.” map can see examples specimen records published iDigBio case. data adjusted iDigBio action recorded data quality flag “rev_geocode_flip_lat_sign.” can visualize data map better understand data quality flag telling us. example, map can see effect accidentally reversing latitude three example georeferenced specimen records.","code":"# Create function to allow subsetting the `df_flagCoord` dataset by other flags # found on these same records df_flagSubset <- function(subsetFlag) {   df_flagCoord %>%    filter(grepl(subsetFlag, flags)) %>%    select(uuid, matches(\"_lat|_lon\")) %>%    unite(provider_coords, c(\"provider_lat\", \"provider_lon\"), sep = \",\") %>%    unite(aggregator_coords, c(\"aggregator_lat\", \"aggregator_lon\"), sep = \",\") %>%    gather(key = type, value = coordinates, -uuid) %>%    separate(coordinates, c(\"lat\",\"lon\"), sep = \",\") %>%    mutate(lat = as.numeric(lat)) %>%    mutate(lon = as.numeric(lon)) %>%    arrange(uuid, type)}  # Subset `df_flagCoord` by records flagged for having had their latitude negated # to place point in stated country by reverse geocoding process df_rev_geocode_lat_sign <- df_flagSubset(\"rev_geocode_lat_sign\")  # Create map displaying a few examples of records with the # rev_geocode_flip_lat_sign flag pal <- leaflet::colorFactor(palette = c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#abdda4\", \"#2b83ba\"),                    domain = df_rev_geocode_lat_sign$uuid[1:10])  map <- df_rev_geocode_lat_sign[1:10,] %>%    mutate(popup = str_c(type, \" = \", lat, \", \", lon, sep = \"\")) %>%    leaflet() %>%   addTiles() %>%    addCircleMarkers(     lng = ~lon,     lat = ~lat,     radius = 10,     weight = 1,     color = ~pal(uuid),     stroke = FALSE,     fillOpacity = 100,     popup = ~popup) %>%      addLegend(\"bottomright\", pal = pal, values = ~uuid,     title = \"Specimen Records\",     opacity = 1)"},{"path":"http://idigbio.github.io/ridigbio/articles/BadCoordinateID.html","id":"summarize-and-explore-data","dir":"Articles","previous_headings":"","what":"Summarize and explore data","title":"Identification of Suspicious Coordinates","text":"iDigBio API provides means institution examine data quality issues across collections, sometimes possible internally data different collections managed different databases. example, can ask many specimen records collections Natural History Museum Los Angeles (LACM) flagged “rev_geocode_corrected” iDigBio. aside, although graph highlights number specimen records data quality issues, represent 0.01% total specimen records published LACM.  can also explore data quality flags specimen records flagged .","code":"# Summarize flagged records by collection type spmByColl <- df_flagCoord %>%    group_by(collectioncode) %>%    tally()  # Generate graph to display counts of flagged records by collection within the # institution graph_spmByColl <- ggplot(spmByColl,                            aes(x = reorder(collectioncode, -n),                                y = n,                               fill = collectioncode)) +   geom_col() +   theme(panel.background = element_blank(),         legend.title = element_blank(),         axis.title.x = element_text(face = \"bold\"),         axis.text.y = element_blank(),         axis.ticks.y = element_blank(),         axis.title.y = element_text(face = \"bold\"),         plot.title = element_text(size = 12, face = \"bold\")) +   labs(x = \"collection\",         y = \"# of specimen records\",        title = \"LACM records flagged with geo-coordinate data quality issues by iDigBio\") +   geom_text(aes(label = n, vjust = -0.5))  # Get count of total records published by the institution using function # `idig_count_records` totalInstSpm <- idig_count_records(rq = list(institutioncode = \"lacm\"))  # Calculate flagged records as percent of total records percentFlagged <- sum(spmByColl$n)/totalInstSpm*100 # Collate `df_flagAssoc` to describe other data quality flags that are associated # with rev_geocode_corrected in `df_flagCoord` df_flagAssoc <- df_flagCoord %>%    select(uuid, flags) %>%    unnest(flags) %>%    group_by(flags) %>%    tally() %>%    mutate(\"category\" = case_when(str_detect(flags, \"geo|country|state\")                               ~ \"geography\",                       str_detect(flags, \"dwc_datasetid_added|dwc_multimedia_added|datecollected_bounds\")                               ~ \"other\",                       str_detect(flags, \"gbif|dwc|tax\")                               ~ \"taxonomy\")) %>%    mutate(\"percent\" = n/(nrow(df_flagCoord))*100) %>%    arrange(category, desc(n))  # Visualize associated data quality flags ggplot(df_flagAssoc, aes(x = reorder(flags, -percent), y = percent, fill = category)) +   geom_col() +   theme(axis.title.x = element_text(face = \"bold\"),         axis.text.x = element_text(angle = 75, hjust = 1),         axis.ticks.y = element_blank(),         axis.title.y = element_text(face = \"bold\"),         plot.title = element_text(size = 12, face = \"bold\")         ) +   labs(x = \"additional iDigBio data quality flag\",         y = \"% specimen records\",        title = \"LACM records flagged for geo-coordinate issues are also flagged for...\",        fill = \"flag category\")"},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Introduction to ridigbio","text":"demo cover : Install ridigbio Search records idig_search_records() Search media records idig_search_media()","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Introduction to ridigbio","text":"First, must install ridigbio package. new R R studio, please refer QUBES module get started: Introduction R Biodiversity Data, doi:10.25334/84FC-TE88 . lastest version R package can installed via CRAN. downloading records, must load ridigbio package.","code":"install.packages(\"ridigbio\") library(ridigbio)"},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"download-records","dir":"Articles","previous_headings":"","what":"Download Records","title":"Introduction to ridigbio","text":"download records Search API, use function idig_search_records(). rq, record query, indicates want download records scientificname equal Galax urceolata. fields specified, default columns include following:","code":"galax_records <- idig_search_records(rq=list(scientificname=\"Galax urceolata\")) colnames(galax_records) ##  [1] \"uuid\"               \"occurrenceid\"       \"catalognumber\"      ##  [4] \"family\"             \"genus\"              \"scientificname\"     ##  [7] \"country\"            \"stateprovince\"      \"geopoint.lon\"       ## [10] \"geopoint.lat\"       \"data.dwc:eventDate\" \"data.dwc:year\"      ## [13] \"data.dwc:month\"     \"data.dwc:day\"       \"collector\"          ## [16] \"recordset\""},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"more-ways-to-search","dir":"Articles","previous_headings":"Download Records","what":"More ways to search","title":"Introduction to ridigbio","text":"addition scientificname, record query may based many fields. example, can search members familyDiapensiaceae: want read points family within extent? Hint: Use iDigBio portal determine bounding box region interest. bounding box delimits geographic extent. Search using input just made","code":"diapensiaceae_records <- idig_search_records(rq=list(family=\"Diapensiaceae\"), limit=1000) rq_input <- list(\"scientificname\"=list(\"type\"=\"exists\"),                  \"family\"=\"Diapensiaceae\",                   geopoint=list(                    type=\"geo_bounding_box\",                    top_left=list(lon = -98.16, lat = 48.92),                    bottom_right=list(lon = -64.02, lat = 23.06)                    )                  ) diapensiaceae_records_USA <- idig_search_records(rq_input, limit=1000)"},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"download-media-records","dir":"Articles","previous_headings":"","what":"Download Media Records","title":"Introduction to ridigbio","text":"download media records Media API, use function idig_search_media(). rq, record query, indicates want download records scientificname equal Galax urceolata. fields specified, default columns include following:","code":"galax_media <- idig_search_media(rq=list(scientificname=\"Galax urceolata\")) colnames(galax_media) ##  [1] \"accessuri\"      \"datemodified\"   \"dqs\"            \"etag\"           ##  [5] \"flags\"          \"format\"         \"hasSpecimen\"    \"licenselogourl\" ##  [9] \"mediatype\"      \"modified\"       \"recordids\"      \"records\"        ## [13] \"recordset\"      \"rights\"         \"tag\"            \"type\"           ## [17] \"uuid\"           \"version\"        \"webstatement\"   \"xpixels\"        ## [21] \"ypixels\""},{"path":"http://idigbio.github.io/ridigbio/articles/BasicUsage.html","id":"more-ways-to-search-1","dir":"Articles","previous_headings":"Download Media Records","what":"More ways to search","title":"Introduction to ridigbio","text":"media search retained 331 rows, however observations information accessuri field. obtain records acessuri, indicate want records data.ac:accessURI exist, setting mq, media query, followed: Now 317 observations accessuri!","code":"galax_media2 <- idig_search_media(rq=list(scientificname=\"Galax urceolata\"),                                   mq=list(\"data.ac:accessURI\"=list(\"type\"=\"exists\")))"},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Fields in ridigbio","text":"demo cover : Identifying raw indexed record fields idig_meta_fields() Downloading fields interest idig_search_records() Identifying raw indexed media record fields idig_meta_fields() Downloading fields interest idig_search_media()","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"search-api-fields","dir":"Articles","previous_headings":"","what":"Search API Fields","title":"Fields in ridigbio","text":"identify raw, verbatim, fields available Search API, can run following: addition fields provided data providers, Search API contains fields indexed potentially modified iDigBio. identify indexed fields available Search API, can run following: Note, fields lists different. However, contain similar information. example, scientificName can found raw index fields.","code":"record_fields <- idig_meta_fields(type = \"records\", subset = \"raw\") rfall <- data.frame(matrix(ncol = 3, nrow = 0))  for(i in 1:length(record_fields)){   if(length(record_fields[[i]]) == 2){     rf <- data.frame(matrix(ncol = 3, nrow = 0))     rf[1, 1] <-  names(record_fields[i])     rf[1, 2] <-  (record_fields[[i]])$type     rf[1, 3] <-  (record_fields[[i]])$fieldName     rfall <- rbind(rfall, rf)   }else{    sub <- record_fields[[i]]     for(j in 1:length(sub)){       rf <- data.frame(matrix(ncol = 3, nrow = 0))       rf[1, 1] <-  names(sub[j])       rf[1, 2] <-  (sub[[j]])$type       rf[1, 3] <-  (sub[[j]])$fieldName       rfall <- rbind(rfall, rf)      }   } } colnames(rfall) <- c(\"name\", \"type\", \"fieldName\") nrow(rfall) ## [1] 317 record_fields_index <- idig_meta_fields(type = \"records\", subset = \"indexed\") rfalli <- data.frame(matrix(ncol = 3, nrow = 0))    for(i in 1:length(record_fields_index)){     if(length(record_fields_index[[i]]) == 2){       rf <- data.frame(matrix(ncol = 3, nrow = 0))       rf[1, 1] <-  names(record_fields_index[i])       rf[1, 2] <-  (record_fields_index[[i]])$type       rf[1, 3] <-  (record_fields_index[[i]])$fieldName       rfalli <- rbind(rfalli, rf)     }else{      sub <- record_fields_index[[i]]       for(j in 1:length(sub)){         rf <- data.frame(matrix(ncol = 3, nrow = 0))         rf[1, 1] <-  names(sub[j])         rf[1, 2] <-  (sub[[j]])$type         rf[1, 3] <-  (sub[[j]])$fieldName         rfalli <- rbind(rfalli, rf)        }     }   } colnames(rfalli) <- c(\"name\", \"type\", \"fieldName\") nrow(rfalli) ## [1] 81 setequal(rfall, rfalli) ## [1] FALSE rfall[238,] ##                   name   type               fieldName ## 238 dwc:samplingEffort string data.dwc:samplingEffort rfalli[69,] ##              name   type      fieldName ## 69 scientificname string scientificname"},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"retain-records-with-these-fields","dir":"Articles","previous_headings":"Search API Fields","what":"Retain records with these fields","title":"Fields in ridigbio","text":"obtain records fields idig_search_records() function, simply list fields arugument equal fields.","code":"out <- idig_search_records(rq=list(scientificname=\"Galax urceolata\"),                             fields = rfall$fieldName)"},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"media-record-api-fields","dir":"Articles","previous_headings":"","what":"Media Record API Fields","title":"Fields in ridigbio","text":"identify raw, verbatim, fields available Media Record API, can run following: Like Search API, Media Record API fields indexed potentially modified iDigBio. identify indexed fields available Media Record API, can run following: Note, index fields associated Media Record API returned default idig_search_media() function.","code":"media_fields <- idig_meta_fields(type = \"media\", subset = \"raw\") mfall <- data.frame(matrix(ncol = 3, nrow = 0))  for(i in 1:length(media_fields)){     if(length(media_fields[[i]]) == 2){       mf <- data.frame(matrix(ncol = 3, nrow = 0))       mf[1, 1] <-  names(media_fields[i])       mf[1, 2] <-  (media_fields[[i]])$type       mf[1, 3] <-  (media_fields[[i]])$fieldName       mfall <- rbind(mfall, mf)     }else{      sub <- media_fields[[i]]       for(j in 1:length(sub)){         mf <- data.frame(matrix(ncol = 3, nrow = 0))         mf[1, 1] <-  names(sub[j])         mf[1, 2] <-  (sub[[j]])$type         mf[1, 3] <-  (sub[[j]])$fieldName         mfall <- rbind(mfall, mf)        }     }   } colnames(mfall) <- c(\"name\", \"type\", \"fieldName\") nrow(mfall) ## [1] 150 media_fields_index <- idig_meta_fields(type = \"media\", subset = \"indexed\") mfalli <- data.frame(matrix(ncol = 3, nrow = 0))  for(i in 1:length(media_fields_index)){     if(length(media_fields_index[[i]]) == 2){       mf <- data.frame(matrix(ncol = 3, nrow = 0))       mf[1, 1] <-  names(media_fields_index[i])       mf[1, 2] <-  (media_fields_index[[i]])$type       mf[1, 3] <-  (media_fields_index[[i]])$fieldName       mfalli <- rbind(mfalli, mf)     }else{      sub <- media_fields_index[[i]]       for(j in 1:length(sub)){         mf <- data.frame(matrix(ncol = 3, nrow = 0))         mf[1, 1] <-  names(sub[j])         mf[1, 2] <-  (sub[[j]])$type         mf[1, 3] <-  (sub[[j]])$fieldName         mfalli <- rbind(mfalli, mf)        }     }   } colnames(mfalli) <- c(\"name\", \"type\", \"fieldName\") nrow(mfalli) ## [1] 21 mfalli$name ##  [1] \"accessuri\"      \"datemodified\"   \"dqs\"            \"etag\"           ##  [5] \"flags\"          \"format\"         \"hasSpecimen\"    \"licenselogourl\" ##  [9] \"mediatype\"      \"modified\"       \"recordids\"      \"records\"        ## [13] \"recordset\"      \"rights\"         \"tag\"            \"type\"           ## [17] \"uuid\"           \"version\"        \"webstatement\"   \"xpixels\"        ## [21] \"ypixels\""},{"path":"http://idigbio.github.io/ridigbio/articles/Fields.html","id":"retain-records-with-these-fields-1","dir":"Articles","previous_headings":"Media Record API Fields","what":"Retain records with these fields","title":"Fields in ridigbio","text":"obtain records fields idig_search_media() function, simply list fields arugument equal fields.","code":"out <- idig_search_media(rq=list(scientificname=\"Galax urceolata\"),                             fields = mfalli$fieldName)"},{"path":"http://idigbio.github.io/ridigbio/articles/FindTissue.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Tissue Samples Locator Demo","text":"demo cover : Write query search specimens using idig_search_records Filter records identify tissue sample Identify contact information collection","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/FindTissue.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load Packages","title":"Tissue Samples Locator Demo","text":"","code":"install.packages('tidyverse',repos = \"http://cran.us.r-project.org\") ##  ## The downloaded binary packages are in ##  /var/folders/98/rnr3bm497gn395gzqtwk917w0000gn/T//RtmptNHILa/downloaded_packages # Load core libraries; install these packages if you have not already library(ridigbio) library(tidyverse)  # Load library for making nice HTML output library(kableExtra)"},{"path":"http://idigbio.github.io/ridigbio/articles/FindTissue.html","id":"write-a-query-to-search-for-specimen-records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimen records","title":"Tissue Samples Locator Demo","text":"First, let’s find specimen records species interested . using idig_search_records function ridigbio package. can learn function iDigBio API documentation ridigbio documentation. example, want search specimens identified one following genera: Manis, Rhinolophus, Paguma. query returned 26913 records iDigBio Portal. preview results look like:","code":"# Edit the fields (e.g. `genus`) and values (e.g. \"manis\") in `list()`  # to adjust your query and the fields (e.g. `uuid`) in `fields` to adjust the # columns returned in your results records <- idig_search_records(rq = list(genus = c(\"manis\",                                                    \"rhinolophus\",                                                    \"paguma\")),                        fields = c(\"uuid\",                                   \"recordset\",                                   \"institutioncode\",                                   \"genus\",                                   \"scientificname\",                                   \"country\",                                   \"data.dwc:year\",                                   \"data.dwc:collectionCode\",                                   \"catalognumber\",                                   \"data.dwc:preparations\"))"},{"path":"http://idigbio.github.io/ridigbio/articles/FindTissue.html","id":"filter-specimen-records-by-preparation-type","dir":"Articles","previous_headings":"","what":"Filter specimen records by preparation type","title":"Tissue Samples Locator Demo","text":"results include specimen records genera interest, now like narrow search include specimens may cryo-preserved tissue available. looking dwc:preparations field information, isn’t controlled vocabulary use data standard. can start summarizing distinct values present field 26913 records:    4   1","code":"# List distinct values for the `preparation` field prepsummary <- records %>%    group_by(`data.dwc:preparations`) %>%    tally()  # Display `prepsummary` in HTML output knitr::kable(prepsummary) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\"),                   full_width = FALSE) %>%    scroll_box(height = \"400px\")"},{"path":"http://idigbio.github.io/ridigbio/articles/FindTissue.html","id":"select-values-to-filter-on-and-apply-filter","dir":"Articles","previous_headings":"Filter specimen records by preparation type","what":"Select values to filter on and apply filter","title":"Tissue Samples Locator Demo","text":"Based distinct values , seems like can use search terms “froze,” “freeze,” “tissue” narrow results. code . Now 465 records, displayed table : can view preparation distinct values present subset data see values might want filter :","code":"# Normalize values in `data.dwc:preparations` to be all lowercase; then # filter rows that include our search terms recordsfiltered <- records %>%    mutate(`data.dwc:preparations` = str_to_lower(`data.dwc:preparations`)) %>%    filter(grepl('freeze|froze|tissue', `data.dwc:preparations`))"},{"path":"http://idigbio.github.io/ridigbio/articles/FindTissue.html","id":"contact-institutions-with-specimens-of-interest","dir":"Articles","previous_headings":"","what":"Contact institutions with specimens of interest","title":"Tissue Samples Locator Demo","text":"data come multiple institutions, wanted examine physical specimens inquire getting tissue samples, need contact institution. can figure contact using results. newly constructed collections data frame contains contact information collections (.e. recordsets) providing data, looks like : ```","code":"# Count how many records in the data were contributed by each recordset recordtally <- recordsfiltered %>%    group_by(recordset) %>%    tally() %>% rename()  # Get metadata from the attributes of the `records` data frame collections <- tibble(collection = attr(recordsfiltered, \"attribution\")) %>%    # Expand information captured in nested lists   hoist(collection,          recordset_uuid = \"uuid\",         recordset_name = \"name\",         recordset_url= \"url\",         contacts = \"contacts\") %>%    # Get rid of extraneous attribution metadata   select(-collection) %>%    # Expand information captured in nested lists   unnest_longer(contacts) %>%    # Expand information captured in nested lists   unnest_wider(contacts) %>%    # Remove any contacts without an email address listed   filter(!is.na(email)) %>%    # Get rid of duplicate contacts within the same recordset   distinct() %>%    # Rename some columns   rename(contact_role = role, contact_email = email) %>%    # Group first and last names together in the same column   unite(col = \"contact_name\",          first_name, last_name,          sep = \" \",          na.rm = TRUE) %>%    # Restructure data frame so that there is one row per recordset   group_by(recordset_uuid) %>%    mutate(contact_index = row_number()) %>%    pivot_wider(names_from = contact_index,                 values_from = c(contact_name, contact_role, contact_email)) %>%   # Include how many records in the data were contributed by each recordset   left_join(recordtally, by = c(\"recordset_uuid\"=\"recordset\")) %>%     # Filter and remove n = 0   filter(!is.na(n)) %>%    # Get rid of any rows which don't actually contribute data to `records`;   # necessary because the attribute metadata by default includes all recordsets   # in iDigBio that match the `idig_search_records` query, even if you filter   # or limit those results in your own code   filter(recordset_uuid %in% records$recordset)"},{"path":"http://idigbio.github.io/ridigbio/articles/IDDataFlags.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Identification of Data Flags","text":"use case iDigBio API look search specimen records specific data quality flag. See information iDigBio’s data quality flags. demo cover : Write query search specimens using idig_search_records Explore data quality flags","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/IDDataFlags.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load Packages","title":"Identification of Data Flags","text":"","code":"install.packages('tidyverse',repos = \"http://cran.us.r-project.org\") ##  ## The downloaded binary packages are in ##  /var/folders/98/rnr3bm497gn395gzqtwk917w0000gn/T//RtmpP0O0tw/downloaded_packages # Load core libraries; install these packages if you have not already library(ridigbio) library(tidyverse)  # Load library for making nice HTML output library(kableExtra)"},{"path":"http://idigbio.github.io/ridigbio/articles/IDDataFlags.html","id":"write-a-query-to-search-for-specimen-records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimen records","title":"Identification of Data Flags","text":"First, let’s find specimen records data quality flag interested . using idig_search_records function ridigbio package. can learn function iDigBio API documentation ridigbio documentation. example, want start searching specimens flagged “rev_geocode_flip” means iDigBio swapped values latitude longitude fields order place coordinate point country stated record. example, iDigBio ingests record coordinates “-87.646166, 41.89542” says collected United States, verbatim coordinates actually plot Antarctica. latitude longitude flipped, coordinates plot United States, iDigBio assumes data provider meant. query result data looks like: data provider wants fix records local collection management system, might useful CSV format rather R. can save results CSV: important data provider data user review results data quality flags confirm iDigBio’s interpretation matches expectations. example, coordinates representing marine localities localities near Antarctica prone misinterpretation.","code":"# Edit the fields (e.g. `flags` or `institutioncode`) and values (e.g.  # \"rev_geocode_flip\" or \"fmnh\") in `list()` to adjust your query and the fields # (e.g. `uuid`) in `fields` to adjust the columns returned in your results records <- idig_search_records(rq = list(flags = \"rev_geocode_flip\",                                               institutioncode = \"fmnh\"),                     fields = c(\"uuid\",                                \"institutioncode\",                                \"collectioncode\",                                \"country\",                                \"data.dwc:country\",                                \"stateprovince\",                                \"county\",                                \"locality\",                                \"geopoint\",                                \"data.dwc:decimalLongitude\",                                \"data.dwc:decimalLatitude\"),                     limit = 100000) %>%    # Rename fields to more easily reflect their provenance (either from the   # data provider directly or modified by the data aggregator)   rename(provider_lon = `data.dwc:decimalLongitude`,          provider_lat = `data.dwc:decimalLatitude`,          provider_country = `data.dwc:country`,          aggregator_lon = `geopoint.lon`,          aggregator_lat = `geopoint.lat`,          aggregator_country = country,          aggregator_stateprovince = stateprovince,          aggregator_county = county,          aggregator_locality = locality) %>%    # Reorder columns for easier viewing   select(uuid, institutioncode, collectioncode, provider_lat, aggregator_lat,          provider_lon, aggregator_lon, provider_country, aggregator_country,          aggregator_stateprovince, aggregator_county, aggregator_locality) # Save `records` as a CSV for reintegration into a local collection management # system write_csv(records, \"records.csv\")"},{"path":"http://idigbio.github.io/ridigbio/articles/MediaAPIDemo.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Media API Demo","text":"demo cover : Write query search specimens using idig_search_media Download media records","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/MediaAPIDemo.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load Packages","title":"Media API Demo","text":"","code":"install.packages('tidyverse',repos = \"http://cran.us.r-project.org\") ##  ## The downloaded binary packages are in ##  /var/folders/98/rnr3bm497gn395gzqtwk917w0000gn/T//RtmpHwK89O/downloaded_packages # Load core libraries; install these packages if you have not already library(ridigbio) library(tidyverse)  # Load library for making nice HTML output library(kableExtra)"},{"path":"http://idigbio.github.io/ridigbio/articles/MediaAPIDemo.html","id":"write-a-query-to-search-for-specimen-records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimen records","title":"Media API Demo","text":"First, need find media records interested downloading media files. using idig_search_media function ridigbio package, allows search media records based data contained linked specimen records, like species collecting locality. can learn function iDigBio API documentation ridigbio documentation. example, want search images herbarium specimens species genus Acer collected United States. result code data frame called records:","code":"# Edit the fields (e.g. `genus`) and values (e.g. \"manis\") in `list()`  # to adjust your query and the fields (e.g. `uuid`) in `fields` to adjust the # columns returned in your results; edit the number after `limit` to adjust the # number of records you will retrieve images for records <- idig_search_media(rq = list(genus = \"acer\",                                        country = \"united states\"),              fields = c(\"uuid\",                        \"accessuri\",                        \"rights\",                        \"format\",                        \"records\"),             limit = 10)"},{"path":"http://idigbio.github.io/ridigbio/articles/MediaAPIDemo.html","id":"generate-a-list-of-urls","dir":"Articles","previous_headings":"","what":"Generate a list of URLs","title":"Media API Demo","text":"Now know media records interest us, need isolate URLs link actual media files can download . example, demonstrate download files cached iDigBio server, well original files hosted externally data provider. likely need download two sets images, can choose comment steps related either “_iDigBio” “_external” depending preference. vectors look like :","code":"# Assemble a vector of iDigBio server download URLs from `records` mediaurl_idigbio <- records %>%    mutate(mediaURL = paste(\"https://api.idigbio.org/v2/media/\", uuid, sep = \"\")) %>%    select(mediaURL) %>%    pull()  # Assemble a vector of external server download URLs from `records` mediaurl_external <- records$accessuri %>%    str_replace(\"\\\\?size=fullsize\", \"\") mediaurl_idigbio ##  [1] \"https://api.idigbio.org/v2/media/0000b146-6fd2-4a6a-bf78-9e709cc995e9\" ##  [2] \"https://api.idigbio.org/v2/media/0000b511-67fd-4485-adea-56df8f7e4c66\" ##  [3] \"https://api.idigbio.org/v2/media/0000d1cd-8211-45c6-8dfa-bd4a9a001aad\" ##  [4] \"https://api.idigbio.org/v2/media/000244a4-6c5c-4e75-9c2e-db585b377935\" ##  [5] \"https://api.idigbio.org/v2/media/000277e9-659b-4e0c-a61b-c5262d33969b\" ##  [6] \"https://api.idigbio.org/v2/media/0002acf9-13d4-4318-a53e-4c00e9361a07\" ##  [7] \"https://api.idigbio.org/v2/media/000495be-df5c-4c01-a951-5656a3fe5ef5\" ##  [8] \"https://api.idigbio.org/v2/media/0005475a-c2c9-4908-9a27-ba9e555d0c43\" ##  [9] \"https://api.idigbio.org/v2/media/00056e02-50b6-4c62-a975-306cc870dd83\" ## [10] \"https://api.idigbio.org/v2/media/000654a2-02f3-4c14-b28a-7567cb55aa57\" mediaurl_external ##  [1] \"http://mam.ansp.org/image/CM/Fullsize/345/CM345773.jpg\"                                                             ##  [2] \"https://sernecportal.org/imglib/seinet/sernec/NCU_VascularPlants/NCU00418/NCU00418780_01.JPG\"                       ##  [3] \"http://mam.ansp.org/image/TAWES/Fullsize/0005/TAWES0005954.jpg\"                                                     ##  [4] \"http://ibss-images.calacademy.org:80/static/botany/originals/12/df/12dff2af-8a4b-4845-9964-79152fb7ce71.jpg\"        ##  [5] \"https://www.pnwherbaria.org/images/jpeg.php?Image=WTU-V-023351.jpg\"                                                 ##  [6] \"https://cch2.org/imglib/cch2/CHSC_VascularPlants/CHSC021/CHSC021794_lg.jpg\"                                         ##  [7] \"http://bgbaseserver.eeb.uconn.edu/DATABASEIMAGES/CONN00075691.JPG\"                                                  ##  [8] \"https://cdn.floridamuseum.ufl.edu/Herbarium/945bc71c-a736-42e2-8b41-7a00bf9529fe\"                                   ##  [9] \"https://data.cyverse.org/dav-anon/iplant/projects/magnoliagrandiFLORA/images/specimens/MISS0038464/MISS0038464.JPG\" ## [10] \"https://api.idigbio.org/v2/media/793b0495f464a5403db6918811399c1d\""},{"path":"http://idigbio.github.io/ridigbio/articles/MediaAPIDemo.html","id":"download-media","dir":"Articles","previous_headings":"","what":"Download media","title":"Media API Demo","text":"can use download URLs assembled step go download media file. clarity, place files two different folders, based whether downloaded iDigBio server external server. name file based unique identifier. now two folders, ten images downloaded iDigBio external servers, respectively. Note downloaded ten images brevity’s sake, can increase using limit argument first step. example one images downloaded:","code":"# Create new directories to save media files in dir.create(\"jpgs_idigbio\") dir.create(\"jpgs_external\")  # Assemble another vector of file paths to use when saving media downloaded  # from iDigBio mediapath_idigbio <- paste(\"jpgs_idigbio/\", records$uuid, \".jpg\", sep = \"\")  # Assemble another vector of file paths to use when saving media downloaded # from external servers; please note that it's probably not a great idea to # assume these files are all jpgs, as we're doing here... mediapath_external <- paste(\"jpgs_external/\", records$uuid, \".jpg\", sep = \"\")  # Add a check to deal with URLs that are broken links possibly_download.file = purrr::possibly(download.file,                                           otherwise = \"cannot download\")  #\"mode\" argument (=\"wb\") in the walk function to download.file.   # Iterate through the action of downloading whatever file is at each # iDigBio URL purrr::walk2(.x = mediaurl_idigbio,              .y = mediapath_idigbio, possibly_download.file)  # Iterate through the action of downloading whatever file is at each # external URL purrr::walk2(.x = mediaurl_external,              .y = mediapath_external, possibly_download.file)"},{"path":"http://idigbio.github.io/ridigbio/articles/ModifiedDataID.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Identification of Modified Data","text":"demo cover : Write query search specimens using idig_search_records Compare difference data providers aggregators data Identify specimen records need reviewed","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/ModifiedDataID.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load Packages","title":"Identification of Modified Data","text":"","code":"install.packages('tidyverse',repos = \"http://cran.us.r-project.org\") ##  ## The downloaded binary packages are in ##  /var/folders/98/rnr3bm497gn395gzqtwk917w0000gn/T//Rtmp7bS46v/downloaded_packages # Load core libraries; install these packages if you have not already library(ridigbio) library(tidyverse)  # Load library for making nice HTML output library(kableExtra)"},{"path":"http://idigbio.github.io/ridigbio/articles/ModifiedDataID.html","id":"write-a-query-to-search-for-specimen-records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimen records","title":"Identification of Modified Data","text":"First, let’s find specimen records given recordset, e.g. records published single collection. using idig_search_records function ridigbio package. can learn function iDigBio API documentation ridigbio documentation. example, want start searching specimens Invertebrate Paleontology collection Natural History Museum Los Angeles. query result data looks like, data aggregator’s processing highlighted red text:","code":"# Edit the value after `recordset` to search for data from a different collection # and the fields (e.g. `uuid`) in `fields` to adjust the columns returned in # your results df_names <- idig_search_records(rq = list(recordset = \"5082e6c8-8f5b-4bf6-a930-e3e6de7bf6fb\"),                     fields = c(\"uuid\",                                \"data.dwc:occurrenceID\",                                \"data.dwc:catalogNumber\",                                \"family\",                                \"data.dwc:family\",                                \"genus\",                                \"data.dwc:genus\",                                \"specificepithet\",                                \"data.dwc:specificEpithet\",                                \"infraspecificepithet\",                                \"data.dwc:infraspecificEpithet\",                                                             \"data.dwc:scientificName\",                                \"flags\"),                     # Set the limit for how many records are returned by the                     # search to a low number for the purposes of this demo                     limit = 1000) %>%    # Rename fields to more easily reflect their provenance (either from the   # data provider directly or modified by the data aggregator)   rename(occurrenceID = `data.dwc:occurrenceID`,          catalogNumber = `data.dwc:catalogNumber`,          provider_family = `data.dwc:family`,          provider_genus = `data.dwc:genus`,          provider_species = `data.dwc:specificEpithet`,          provider_subspecies = `data.dwc:infraspecificEpithet`,          provider_scientificName = `data.dwc:scientificName`,          aggregator_family = `family`,          aggregator_genus = `genus`,          aggregator_species = `specificepithet`,          aggregator_subspecies = `infraspecificepithet`) %>%    # Reorder columns for easier viewing   select(uuid, occurrenceID, catalogNumber, aggregator_family, provider_family,          aggregator_genus, aggregator_species, aggregator_subspecies,           provider_genus, provider_species, provider_subspecies,          provider_scientificName, flags)"},{"path":"http://idigbio.github.io/ridigbio/articles/ModifiedDataID.html","id":"explore-differences-in-the-data","dir":"Articles","previous_headings":"","what":"Explore differences in the data","title":"Identification of Modified Data","text":"can already see formatting differences data provider modified aggregator. example, iDigBio converts data lowercase, historically useful standardizing indexing data across recordsets represented iDigBio database. Family genus names capitalized convention, reformat fields : Let’s use power R filter data modified can focus rows aggregator made changes. example, look rows genus name match provider aggregator: iDigBio makes modifications data, actions recorded data quality flags, instance notice rows filtered data flag “dwc_genus_replaced.” used values flags field, like “dwc_genus_replaced,” search records back beginning demo. can learn flags iDigBio uses .","code":"# Reformat aggregator fields to title case df_names <- df_names %>%    mutate(aggregator_family = str_to_title(aggregator_family)) %>%    mutate(aggregator_genus = str_to_title(aggregator_genus))  # Subset `df_names` to show example df_names[1:5,] %>%    select(-flags) %>%    kable() %>%    kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"),                 font_size = 12,                 fixed_thead = T) %>%    column_spec(c(4,6,7,8), color = \"red\") %>%    scroll_box(width = \"100%\", height = \"400px\") # Filter for rows where genus does not match df_names %>%    filter(provider_genus != aggregator_genus) %>%    kable() %>%    kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"),                 font_size = 12,                 fixed_thead = T) %>%    column_spec(c(4,6,7,8), color = \"red\") %>%    scroll_box(width = \"100%\", height = \"400px\")"},{"path":"http://idigbio.github.io/ridigbio/articles/ModifiedDataID.html","id":"summarize-differences-in-the-data","dir":"Articles","previous_headings":"","what":"Summarize differences in the data","title":"Identification of Modified Data","text":"want make changes based modifications discovered , may helpful summarize distinct modifications, opposed seeing repeated across many individual specimen records. can summarize distinct modifications genus names using group_by tally functions dplyr package. reviewing summarized data, may wish review individual specimens possibly update data. can use information summary search catalog numbers specimens review.","code":"# Summarize modifications made to genus names df_names %>%    filter(provider_genus != aggregator_genus) %>%    # Because of the nature of scientific names, it makes sense to group data by   # all of the primary fields that comprise a scientific name   group_by(provider_genus, provider_species, provider_subspecies,            aggregator_genus, aggregator_species, aggregator_subspecies,            provider_scientificName) %>%    # Count how many rows are affected by this modification made to genus name   tally() %>%    # Order by frequency of rows affected   arrange(desc(n)) %>%    kable() %>%    kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"),                 font_size = 12,                 fixed_thead = T) %>%    column_spec(c(4,5,6), color = \"red\") %>%    scroll_box(width = \"100%\", height = \"400px\") # Search for specimen records of an example modified genus name df_names %>%    filter(provider_genus == \"Glossaulax\" & provider_species == \"reclusiana\") %>%   select(catalogNumber) ##       catalogNumber ## 1   LACMIP 8226.206 ## 2   LACMIP 20187.59 ## 3   LACMIP 42035.85 ## 4   LACMIP 41678.50 ## 5   LACMIP 25446.87 ## 6  LACMIP 22413.169 ## 7     LACMIP 2685.9 ## 8    LACMIP 4396.20 ## 9     LACMIP 466.63 ## 10  LACMIP 31263.78 ## 11 LACMIP 16520.155 ## 12  LACMIP 17650.56"},{"path":"http://idigbio.github.io/ridigbio/articles/RecordAPIDemo.html","id":"general-overview","dir":"Articles","previous_headings":"","what":"General Overview","title":"Record API Demo","text":"can use iDigBio API find specimen records using search parameters available iDigBio Portal. Wrappers like ridigbio, covering demo, provide simple way use iDigBio API context research pipeline. already use, considering using, R data exploration analysis, makes sense bring data R directly iDigBio via API. demo cover brief overview fundamental functions ridigbio package can use make research pipeline reproducible. demo cover : Write query search specimens using idig_search_records Quickly get count many specimens match query using idig_count_records Discover frequent values field using idig_top_records","code":""},{"path":"http://idigbio.github.io/ridigbio/articles/RecordAPIDemo.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load Packages","title":"Record API Demo","text":"","code":"install.packages('tidyverse',repos = \"http://cran.us.r-project.org\") ##  ## The downloaded binary packages are in ##  /var/folders/98/rnr3bm497gn395gzqtwk917w0000gn/T//Rtmpb0uBva/downloaded_packages # Load core libraries; install these packages if you have not already library(ridigbio) library(tidyverse)  # Load library for making nice HTML output library(kableExtra)"},{"path":"http://idigbio.github.io/ridigbio/articles/RecordAPIDemo.html","id":"write-a-query-to-search-for-specimens-using-idig_search_records","dir":"Articles","previous_headings":"","what":"Write a query to search for specimens using idig_search_records","title":"Record API Demo","text":"use interface like iDigBio Portal, already writing query search specimens. new coding, can helpful begin figuring query user-friendly interface Portal, translating code R understand want search . One hardest parts using ridigbio search specimen records know field want search named. iDigBio API provides list field names , need reference sources, like documentation Darwin Core standard, understand kind information fields typically contain. matsumura palmer prince; j. . berly; o. l. cartwright stevenson powell jr. rosenkrans hyams walker hill, h. douglass feng henry young jones godfrey prince hermann kao gray hall michaux warter dunlop hill, h. douglass boyaton godfrey hatusima freeman tschonoski kao bossart midorikawa prince, j. . berly, o. l. cartwright batchelor prince; j. . berly; o. l. cartwright gray, c. s. sargent, j. h. redfield & w. m. canby hyams prince suzuki oosting hyams griggs prince rosenkrans prince, j. . berly & o. l. cartwright house darling davies tamura boynton crandall boynton hyams takamine amano moore prince; j. . berly; o. l. cartwright walker cole krebs togashi & y. tateishi boynton davies davis prince; j. . berly & o. l. cartwright kubo, m. togasi & t. matsuoka averyanov&#124;p.k. lôc&#124;n.t. vinh&#124;. averyanova crayton boynton boynton hill barnes kral keng powell, jr. hill rosenkrans rosenkrans tschonoski kao barnes prince; j. . berly, o.l.cartwright powell, jr. walker, s. sonohara, s. tawada & t. amano prince, j. berley & o. cartwright hyams rosenkrans tschonoski powell, jr. jerabek hyams hill latham mullens perkins harris prince","code":"# Let's start with a simple search introducing the primary arguments for the # function `idig_search_records` records_1A <- idig_search_records(   # `rq` is where you adjust your record query   rq = list(genus = \"shortia\"),   # `fields` is where you adjust what fields you want returned by the API   fields = c(\"uuid\",              \"family\",              \"genus\",              \"specificepithet\",              \"scientificname\",              \"stateprovince\"),   # `limit` is where you can set a limit on the number of records to return in   # order to speed up your query; max is 100000   limit = 10,   # `sort` is where you can specify fields for sorting   sort = c(\"stateprovince\",            \"scientificname\"))  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_1A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # Now let's repeat the same search but remove all arguments other than `rq` to # see what the defaults for the other arguments look like records_1B <- idig_search_records(   rq = list(genus = \"shortia\"))  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_1B) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # In the example above, we are only using one parameter in `rq` to define our # query, but now let's search by multiple parameters records_2A <- idig_search_records(   rq = list(basisofrecord = \"fossilspecimen\",             # Use `type = \"exists\"` to search for rows where there is a value             # present in this field; the inverse of this is `type = \"missing\"`             geopoint = list(type = \"exists\")),   limit = 10)  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_2A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # What if we wanted to see more fields than the default provides? Using the same # search as above, we can retrieve all indexed fields with `fields = \"all\"` records_2B <- idig_search_records(   rq = list(basisofrecord = \"fossilspecimen\",           geopoint = list(type=\"exists\")),   fields = \"all\",   limit = 10)  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_2B) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # But wait, there are even more fields available than just those we retrieved # in the query above! Using the same search, we can choose exactly what fields # to retrieve from indexed and raw data if we call the fields out by name in # the `fields` argument; raw data fields are prefaced by \"data.dwc:\" and use  # camelCase in their naming convention (vs. lowercase for iDigBio fields) records_2C <- idig_search_records(   rq = list(basisofrecord = \"fossilspecimen\",           geopoint = list(type=\"exists\")),   # Here is where we are explicitly asking for specific fields   fields = c(\"uuid\",              \"recordset\",              \"institutioncode\", \"data.dwc:institutionCode\",              \"country\", \"data.dwc:country\",              \"countrycode\", \"data.dwc:countryCode\",              \"stateprovince\", \"data.dwc:stateProvince\",              \"locality\", \"data.dwc:locality\",              \"geopoint\", \"data.dwc:decimalLongitude\", \"data.dwc:decimalLatitude\"),   limit = 10)  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_2C) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\") # You may be curious what the difference is between indexed and raw data such as # that we saw in the search above. Indexed data has been altered by iDigBio # (often in an attempt to standardize and/or correct values), and raw data is # what was provided to iDigBio by the data provider, i.e. the natural history # collection. Here we will do a new search on a data quality flag to view # differences between indexed and raw data records_3A <- idig_search_records(   # Data quality flags are a way for iDigBio to communicate how data was altered   # during its quality control process, i.e. how the indexed and raw data differ   rq = list(flags = \"rev_geocode_lat_sign\"),   fields = c(\"uuid\",              \"institutioncode\", \"data.dwc:institutionCode\",              \"country\", \"data.dwc:country\",              \"countrycode\", \"data.dwc:countryCode\",              \"stateprovince\", \"data.dwc:stateProvince\",              \"locality\", \"data.dwc:locality\",              \"geopoint\", \"data.dwc:decimalLongitude\", \"data.dwc:decimalLatitude\"),   limit = 10)  # Let's format our results to be more readable by renaming and reordering columns records_3A <- records_3A %>%    rename_at(vars(starts_with(\"data.dwc:\")),             ~str_replace(., \"data.dwc:\", \"raw_\")) %>%    select(uuid,          indexed_decimalLatitude = geopoint.lat,          raw_decimalLatitude,          indexed_decimalLongitude = geopoint.lon,          raw_decimalLongitude,          everything())  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(records_3A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\")"},{"path":"http://idigbio.github.io/ridigbio/articles/RecordAPIDemo.html","id":"quickly-get-a-count-of-how-many-specimens-match-a-query-using-idig_count_records","dir":"Articles","previous_headings":"","what":"Quickly get a count of how many specimens match a query using idig_count_records","title":"Record API Demo","text":"Sometimes number records matching query important purposes records , instance trying calculate many fossil specimens iDigBio geographic coordinate data. can use query format idig_count_records can idig_search_records answer question “many records query return?” quickly. function also useful suspect query might return 100,000 records, limit single iteration idig_search_records.","code":"# Let's test out a search using parameters we know would retrieve many records count_1A <- idig_count_records(   rq = list(basisofrecord = \"fossilspecimen\",           geopoint = list(type=\"exists\")))  # We can reformat our result to be more readable count_1A <- format(count_1A, big.mark = \",\")  # This number shows how many records in iDigBio have a value of \"fossilspecimen\" # as well as geographic coordinate data count_1A ## [1] \"3,205,547\""},{"path":"http://idigbio.github.io/ridigbio/articles/RecordAPIDemo.html","id":"discover-the-most-frequent-values-for-a-field-using-idig_top_records","dir":"Articles","previous_headings":"","what":"Discover the most frequent values for a field using idig_top_records","title":"Record API Demo","text":"trouble understanding kind information lives particular field, may useful look common values exist field. idig_top_records function can show . , function uses basic rq argument define query.","code":"# Let's go back to our first simple search and see what the top values are for # `scientificname` where the genus is \"shortia\" top_1A <- idig_top_records(   # `rq` is where you adjust your record query   rq = list(genus = \"shortia\"),   # `top_fields` is where you adjust what fields you want to see summarized   top_fields = \"scientificname\",   # `count` is where you can set a limit on the number of top values to return   # in order to speed up your query; max is 1000   count = 10)  # We need to convert our results from a nested list into a more readable format top_1A <- as_tibble(top_1A$scientificname) %>%    pivot_longer(everything(), names_to = \"scientificname\", values_to = \"count\")  # Display the data frame we just created above in a nice pretty table for HTML knitr::kable(top_1A) %>%      kable_styling(bootstrap_options =                           c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%    scroll_box(height = \"300px\")"},{"path":"http://idigbio.github.io/ridigbio/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Francois Michonneau. Author, copyright holder.            Original Author Matthew Collins. Author.            Original Author Scott Chamberlain. Contributor. Kevin Love. Contributor. Hem Nalini Morzaria-Luna. Contributor. Michelle L. Gaynor. Contributor, author. Jesse Bennett. Maintainer.            Maintainer","code":""},{"path":"http://idigbio.github.io/ridigbio/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Michonneau F, Collins M, Gaynor M (2024). ridigbio: Interface iDigBio Data API. R package version 0.3.9, https://CRAN.R-project.org/package=ridigbio.","code":"@Manual{,   title = {ridigbio: Interface to the iDigBio Data API},   author = {Francois Michonneau and Matthew Collins and Michelle L. Gaynor},   year = {2024},   note = {R package version 0.3.9},   url = {https://CRAN.R-project.org/package=ridigbio}, }"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"ridigbio-","dir":"","previous_headings":"","what":"Interface to the iDigBio Data API","title":"Interface to the iDigBio Data API","text":"ridigbio R package access iDigBio (Integrated Digitized Biocollections).","code":""},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Interface to the iDigBio Data API","text":"ridigbio avaliable via CRAN.","code":"install.packages(\"ridigbio\")"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"error-messages","dir":"","previous_headings":"Installation","what":"Error Messages","title":"Interface to the iDigBio Data API","text":"R says package unavailable, may set CRAN mirror. can : R says binary package available, version R may old. Please review versions R CRAN built packages CRAN ridigbio package page. can download source package install manually package built version R. may also need install dependencies. Linux, may encounter error installation process libcurl installed. method installing libcurl vary distributions, Ubuntu can install latest version via:","code":"chooseCRANmirror() install.packages(\"ridigbio\", type=\"source\") sudo apt install libcurl4"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Interface to the iDigBio Data API","text":"several articles can help get started: Introduction ridigbio Record API Demo Media API Demo Fields ridigibio Tissue Samples Locator Demo Identification Modified Data Identification Suspicious Coordinates Identification Data Flags iDigBio users interested downloading occurrence records:","code":"library(\"ridigbio\") idig_search_records(rq=list(genus=\"galax\")) idig_search_records(rq=list(family=\"diapensiaceae\"), limit=1000)"},{"path":"http://idigbio.github.io/ridigbio/index.html","id":"meta","dir":"","previous_headings":"","what":"Meta","title":"Interface to the iDigBio Data API","text":"Please report bugs issues. License: MIT","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":null,"dir":"Reference","previous_headings":"","what":"Build fields and fields_exclude for queries. — build_field_lists","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"Given desired fields returned, intelligently add exclusion data array warranted handle \"\" keyword. without setting fields fields_exclude due fact API return wrong results passed. still posssible user deliberately sets . exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"","code":"build_field_lists(fields, type)"},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"fields character vector fields user wants returned type type records get fields ","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/build_field_lists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build fields and fields_exclude for queries. — build_field_lists","text":"list list fields key df fields query key parameters merged query sent","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/dot-onAttach.html","id":null,"dir":"Reference","previous_headings":"","what":"onAttach — .onAttach","title":"onAttach — .onAttach","text":"Display startup message","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/dot-onAttach.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"onAttach — .onAttach","text":"","code":".onAttach(...)"},{"path":"http://idigbio.github.io/ridigbio/reference/dot-onAttach.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"onAttach — .onAttach","text":"... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":null,"dir":"Reference","previous_headings":"","what":"internal GET request — idig_GET","title":"internal GET request — idig_GET","text":"Internal function GET requests.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"internal GET request — idig_GET","text":"","code":"idig_GET(path, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"internal GET request — idig_GET","text":"path endpoint ... additional arguments passed httr::GET","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"internal GET request — idig_GET","text":"request (list)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"internal GET request — idig_GET","text":"Generates GET request performs checks returned. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_GET.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"internal GET request — idig_GET","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":null,"dir":"Reference","previous_headings":"","what":"internal POST request — idig_POST","title":"internal POST request — idig_POST","text":"Internal function POST requests.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"internal POST request — idig_POST","text":"","code":"idig_POST(path, body, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"internal POST request — idig_POST","text":"path endpoint body list parameters endpoint ... additional arguments passed httr::POST","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"internal POST request — idig_POST","text":"request (list)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"internal POST request — idig_POST","text":"Generates POST request performs checks returned. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_POST.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"internal POST request — idig_POST","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":null,"dir":"Reference","previous_headings":"","what":"Attribution dataframe of iDigBio records query — idig_build_attrib","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"Function build attribution dataframe query iDigBio API","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"","code":"idig_build_attrib(dat)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"dat dataframe generated idig_search method","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"data frame","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"function differs attribution metadata attached dataframe returned idig_search_* methods. summarizes record sets used records dataframe, record sets records match query sent iDigBio. useful part records query downloaded, example limit offset parameters. Exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_build_attrib.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Attribution dataframe of iDigBio records query — idig_build_attrib","text":"Kevin Love","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":null,"dir":"Reference","previous_headings":"","what":"check HTTP code — idig_check","title":"check HTTP code — idig_check","text":"Checks HTTP error codes JSON errors.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check HTTP code — idig_check","text":"","code":"idig_check(req)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check HTTP code — idig_check","text":"req returned request","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check HTTP code — idig_check","text":"nothing. Stops HTTP code >= 400","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"check HTTP code — idig_check","text":"Part 1 error checking process. part handles HTTP error codes calls part 2 handles JSON errors responses. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"check HTTP code — idig_check","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Check is the request returned an error. — idig_check_error","title":"Check is the request returned an error. — idig_check_error","text":"Checks error messages can returned API JSON.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check is the request returned an error. — idig_check_error","text":"","code":"idig_check_error(req)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check is the request returned an error. — idig_check_error","text":"req returned request","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check is the request returned an error. — idig_check_error","text":"nothing. Stops request contains error.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check is the request returned an error. — idig_check_error","text":"Part 2 error checking process. Checks JSON response error messages stops found. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_check_error.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check is the request returned an error. — idig_check_error","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":null,"dir":"Reference","previous_headings":"","what":"Count media endpoint — idig_count_media","title":"Count media endpoint — idig_count_media","text":"Count media records matching query.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count media endpoint — idig_count_media","text":"","code":"idig_count_media(rq = FALSE, mq = FALSE, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count media endpoint — idig_count_media","text":"rq iDigBio record query nested list format mq iDigBio media query nested list format ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count media endpoint — idig_count_media","text":"count media records matching query(s)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count media endpoint — idig_count_media","text":"Quickly return count media records matching query(s) provided.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count media endpoint — idig_count_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":null,"dir":"Reference","previous_headings":"","what":"Count record endpoint — idig_count_records","title":"Count record endpoint — idig_count_records","text":"Count specimen records matching query.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count record endpoint — idig_count_records","text":"","code":"idig_count_records(rq = FALSE, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count record endpoint — idig_count_records","text":"rq iDigBio record query nested list format ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count record endpoint — idig_count_records","text":"count specimen records matching query(s)","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count record endpoint — idig_count_records","text":"Quickly return count specimen records matching query(s) provided.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_count_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count record endpoint — idig_count_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"meta fields endpoint — idig_meta_fields","title":"meta fields endpoint — idig_meta_fields","text":"List fields iDigBio.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"meta fields endpoint — idig_meta_fields","text":"","code":"idig_meta_fields(type = \"records\", subset = FALSE, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"meta fields endpoint — idig_meta_fields","text":"type string type fields return, defaults \"records\" subset set fields return, \"indexed\", \"raw\", unset ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"meta fields endpoint — idig_meta_fields","text":"list fields requested type","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"meta fields endpoint — idig_meta_fields","text":"Return list media specimen fields contained iDigBio.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_meta_fields.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"meta fields endpoint — idig_meta_fields","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"parse successfully returned request — idig_parse","title":"parse successfully returned request — idig_parse","text":"Parses output successful query return list.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"parse successfully returned request — idig_parse","text":"","code":"idig_parse(req)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"parse successfully returned request — idig_parse","text":"req returned request","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"parse successfully returned request — idig_parse","text":"list","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"parse successfully returned request — idig_parse","text":"exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_parse.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"parse successfully returned request — idig_parse","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic searching of iDigBio records — idig_search","title":"Basic searching of iDigBio records — idig_search","text":"Base function query iDigBio API","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic searching of iDigBio records — idig_search","text":"","code":"idig_search(   type = \"records\",   mq = FALSE,   rq = FALSE,   fields = FALSE,   max_items = 1e+05,   limit = 0,   offset = 0,   sort = FALSE,   ... )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic searching of iDigBio records — idig_search","text":"type string type records query, defaults \"records\" mq iDigBio media query nested list format rq iDigBio record query nested list format fields vector fields contained data.frame max_items CURRENTLY IGNORED, SEE ISSUE #33 maximum number results allowed retrieved (fail-safe) limit maximum number results returned offset number results skip returning results sort vector fields use sorting, UUID always appended make paging safe ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic searching of iDigBio records — idig_search","text":"data frame","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basic searching of iDigBio records — idig_search","text":"function wrapped media specimen record searches. Please consider using idig_search_media idig_search_records instead supply nice defaults function depending type records desired. Fuller documentation parameters idig_search_records function's help. Exported facilitate wrapping package packages.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Basic searching of iDigBio records — idig_search","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic searching of iDigBio records — idig_search","text":"","code":"if (FALSE) { # Ten media records related to genus Acer specimens idig_search(type=\"media\", rq=list(genus=\"acer\"), limit=10) }"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":null,"dir":"Reference","previous_headings":"","what":"Searching of iDigBio media records — idig_search_media","title":"Searching of iDigBio media records — idig_search_media","text":"Function query iDigBio API media records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Searching of iDigBio media records — idig_search_media","text":"","code":"idig_search_media(   mq = FALSE,   rq = FALSE,   fields = FALSE,   max_items = 1e+05,   limit = 0,   offset = 0,   sort = FALSE,   ... )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Searching of iDigBio media records — idig_search_media","text":"mq iDigBio media query nested list format rq iDigBio record query nested list format fields vector fields contained data.frame, defaults \"\" indexed fields max_items maximum number results allowed retrieved (fail -safe) limit maximum number results returned offset number results skip returning results sort vector fields use sorting, UUID always appended make paging safe ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Searching of iDigBio media records — idig_search_media","text":"data frame fields requested following default fields: accessuri datemodified: Date last modified, assigned iDigBio. dqs: Data quality score assigned iDigBio. etag: Tag assigned iDigBio. flags: Data quality flag assigned iDigBio. format hasSpecimen: TRUE FALSE, indicates associated record media. licenselogourl mediatype: Media object type. modified recordids: List UUID associated records. records: UUID associated record. recordset: Record set ID assigned iDigBio. rights tag type uuid: Unique identifier assigned iDigBio. version: Media record version assigned iDigBio. webstatement xpixels: defined EXIF, x dimension pixel. ypixels: defined EXIF,y dimension pixels.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Searching of iDigBio media records — idig_search_media","text":"Also see idig_search_records full examples parameters related searching iDigBio. Wraps idig_search provide defaults specific searching media records. Using function instead idig_search directly recommened. Record queries media queries objects allowed (rq mq parameters) media records returned match requirements . function defaults returning indexed media record fields.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Searching of iDigBio media records — idig_search_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_media.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Searching of iDigBio media records — idig_search_media","text":"","code":"if (FALSE) { # Searching for media using a query on related specimen information - first # 10 media records with image URIs related to a specimen in the genus Acer: df <- idig_search_media(rq=list(genus=\"acer\"),                         mq=list(\"data.ac:accessURI\"=list(\"type\"=\"exists\")),                         fields=c(\"uuid\",\"data.ac:accessURI\"), limit=10) }"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":null,"dir":"Reference","previous_headings":"","what":"Searching of iDigBio records — idig_search_records","title":"Searching of iDigBio records — idig_search_records","text":"Function query iDigBio API specimen records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Searching of iDigBio records — idig_search_records","text":"","code":"idig_search_records(   rq,   fields = FALSE,   max_items = 1e+05,   limit = 0,   offset = 0,   sort = FALSE,   ... )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Searching of iDigBio records — idig_search_records","text":"rq iDigBio record query nested list format fields vector fields contained data.frame, limited set returned default, use \"\" get indexed fields max_items maximum number results allowed retrieved (fail -safe) limit maximum number results returned offset number results skip returning results sort vector fields use sorting, UUID always appended make paging safe ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Searching of iDigBio records — idig_search_records","text":"data frame fields requested following default fields: UUID: Unique identifier assigned iDigBio. occurrenceID catalognumber family - may reassigned iDigBio genus - may reassigned iDigBio scientificname - may reassigned iDigBio country - may modified iDigBio stateprovince geopoint: Assigned iDigBio. data.dwc:eventDate data.dwc:year data.dwc:month data.dwc:day datecollected: May reassigned iDigBio, see collector: Assigned iDigBio. recordset: Assigned iDigBio.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Searching of iDigBio records — idig_search_records","text":"Wraps idig_search provide defaults specific searching specimen records. Using function instead idig_search directly recommened. Queries need specified nested list structure serialize iDigBio query object's JSON expected iDigBio API: https://github.com/iDigBio/idigbio-search-api/wiki/Query-Format example, first sample query looks like JSON API documentation: rewrite R use rq parameter idig_search_records idig_search_media, look like : example complex JSON query nested structures: rewrite R use rq parameter, use nested calls list() function: See Examples section samples simpler complex queries. Please refer API documentation full functionality availible queries. matching results returned max_items cap (default 100,000). results wanted, higher max_items can passed option. API loads records 5,000 time using HTTP performance large sets data good. Expect result sets 50,000 records take tens minutes. can use idig_count_records idig_count_media functions find many records query return; fast. iDigBio API return 5,000 records time function automatically page results return . Limit offset availible manual paging results needed though max_items cap still applies. item count comes results header count actual records limit/offset window. Return data.frame containing requested fields (default fields). columns data frame untyped factors pre- built. Attribution metadata attached dataframe data.frame's attributes. (.e. attributes(df))","code":"{   \"scientificname\": {     \"type\": \"exists\"   },   \"family\": \"asteraceae\" } rq <- list(\"scientificname\"=list(\"type\"=\"exists\"),            \"family\"=\"asteraceae\"            ) {   \"geopoint\": {    \"type\": \"geo_bounding_box\",    \"top_left\": {      \"lat\": 19.23,      \"lon\": -130     },     \"bottom_right\": {       \"lat\": -45.1119,       \"lon\": 179.99999     }    }  } rq <- list(geopoint=list(                          type=\"geo_bounding_box\",                          top_left=list(lat=19.23, lon=-130),                          bottom_right=list(lat=-45.1119, lon= 179.99999)                         )            )"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Searching of iDigBio records — idig_search_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_search_records.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Searching of iDigBio records — idig_search_records","text":"","code":"if (FALSE) { # Simple example of retriving records in a genus: idig_search_records(rq=list(genus=\"acer\"), limit=10)  # This complex query shows that booleans passed to the API are represented # as strings in R, fields used in the query don't have to be returned, and # the syntax for accessing raw data fields: idig_search_records(rq=list(\"hasImage\"=\"true\", genus=\"acer\"),             fields=c(\"uuid\", \"data.dwc:verbatimLatitude\"), limit=100)  # Searching inside a raw data field for a string, note that raw data fields # are searched as full text, indexed fields are search with exact matches:  idig_search_records(rq=list(\"data.dwc:dynamicProperties\"=\"parasite\"),             fields=c(\"uuid\", \"data.dwc:dynamicProperties\"), limit=100)  # Retriving a data.frame for use with MaxEnt. Notice geopoint is expanded # to two columns in the data.frame: gepoint.lat and geopoint.lon: df <- idig_search_records(rq=list(genus=\"acer\", geopoint=list(type=\"exists\")),           fields=c(\"uuid\", \"geopoint\"), limit=10) write.csv(df[c(\"uuid\", \"geopoint.lon\", \"geopoint.lat\")],           file=\"acer_occurrences.csv\", row.names=FALSE)  }"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":null,"dir":"Reference","previous_headings":"","what":"Top media endpoint — idig_top_media","title":"Top media endpoint — idig_top_media","text":"Top media records summaries.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Top media endpoint — idig_top_media","text":"","code":"idig_top_media(rq = FALSE, mq = FALSE, top_fields = FALSE, count = 0, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Top media endpoint — idig_top_media","text":"rq iDigBio record query nested list format mq iDigBio media query nested list format top_fields vector field names summarize count maximum number results return, capped 1000 ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Top media endpoint — idig_top_media","text":"nested list field values counts media records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Top media endpoint — idig_top_media","text":"Summarize count media records iDigBio according unique values fields passed. operates similarly SELECT DISTINCT count( field_name) query SQL. multiple fields passed, summaries nested eg fields=c(\"country\", \"genus\") result counting top 10 genera top 10 countries total 100 counts.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Top media endpoint — idig_top_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":null,"dir":"Reference","previous_headings":"","what":"Top records endpoint — idig_top_records","title":"Top records endpoint — idig_top_records","text":"Top specimen records summaries.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Top records endpoint — idig_top_records","text":"","code":"idig_top_records(rq = FALSE, top_fields = FALSE, count = 0, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Top records endpoint — idig_top_records","text":"rq iDigBio record query nested list format top_fields vector field names summarize count maximum number results return, capped 1000 ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Top records endpoint — idig_top_records","text":"nested list field values counts specimen records","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Top records endpoint — idig_top_records","text":"Summarize count specimen records iDigBio according unique values fields passed. operates similarly SELECT DISTINCT count(field_name) query SQL. multiple fields passed, summaries nested eg fields=c(\"country\", \"genus\") result counting top 10 genera top 10 countries total 100 counts.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_top_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Top records endpoint — idig_top_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":null,"dir":"Reference","previous_headings":"","what":"base URL — idig_url","title":"base URL — idig_url","text":"Return base URL API calls.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"base URL — idig_url","text":"","code":"idig_url(dev = FALSE)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"base URL — idig_url","text":"dev beta version API used?","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"base URL — idig_url","text":"string URL","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"base URL — idig_url","text":"Defaults use beta URL. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_url.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"base URL — idig_url","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":null,"dir":"Reference","previous_headings":"","what":"validate fields — idig_validate","title":"validate fields — idig_validate","text":"Stub function validating parameters.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"validate fields — idig_validate","text":"","code":"idig_validate(inputs)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"validate fields — idig_validate","text":"inputs list inputs validate","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"validate fields — idig_validate","text":"boolean","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"validate fields — idig_validate","text":"Takes list inputs named validation rule eg: number:[2, 3] returns vector strings validation errors. vector 0 length, everything valid. exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_validate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"validate fields — idig_validate","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":null,"dir":"Reference","previous_headings":"","what":"API version — idig_version","title":"API version — idig_version","text":"Return version number use API calls.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"API version — idig_version","text":"","code":"idig_version(version = \"v2\")"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"API version — idig_version","text":"version optional argument giving version API use","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"API version — idig_version","text":"string version use","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"API version — idig_version","text":"current default \"v2\". exported.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_version.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"API version — idig_version","text":"Francois Michonneau","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":null,"dir":"Reference","previous_headings":"","what":"view media endpoint — idig_view_media","title":"view media endpoint — idig_view_media","text":"View individual media records.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"view media endpoint — idig_view_media","text":"","code":"idig_view_media(uuid, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"view media endpoint — idig_view_media","text":"uuid uuid media record ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"view media endpoint — idig_view_media","text":"nested list data","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"view media endpoint — idig_view_media","text":"View information specific media record.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_media.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"view media endpoint — idig_view_media","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":null,"dir":"Reference","previous_headings":"","what":"view specimen endpoint — idig_view_records","title":"view specimen endpoint — idig_view_records","text":"View individual specimen records.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"view specimen endpoint — idig_view_records","text":"","code":"idig_view_records(uuid, ...)"},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"view specimen endpoint — idig_view_records","text":"uuid uuid specimen record ... additional parameters","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"view specimen endpoint — idig_view_records","text":"nested list data","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"view specimen endpoint — idig_view_records","text":"View information specific specimen record.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/idig_view_records.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"view specimen endpoint — idig_view_records","text":"Matthew Collins","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ignore_unused_imports.html","id":null,"dir":"Reference","previous_headings":"","what":"Stub function for passing import checks — ignore_unused_imports","title":"Stub function for passing import checks — ignore_unused_imports","text":"Stub function passing import checks","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ignore_unused_imports.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stub function for passing import checks — ignore_unused_imports","text":"","code":"ignore_unused_imports()"},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ridigbio: Interface to the iDigBio Data API — ridigbio-package","title":"ridigbio: Interface to the iDigBio Data API — ridigbio-package","text":"interface iDigBio's search API allows downloading specimen records. Searches returned data.frame. functions metadata end points return lists information. iDigBio US project focused digitizing serving museum specimen collections web. See https://www.idigbio.org information iDigBio.","code":""},{"path":[]},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ridigbio: Interface to the iDigBio Data API — ridigbio-package","text":"Maintainer: Jesse Bennett j3553@ufl.edu (Maintainer) Authors: Francois Michonneau francois.michonneau@gmail.com (Original Author) [copyright holder] Matthew Collins mcollins@acis.ufl.edu (Original Author) Michelle L. Gaynor michellegaynor@ufl.edu [contributor] contributors: Scott Chamberlain myrmecocystus@gmail.com [contributor] Kevin Love klove@flmnh.ufl.edu [contributor] Hem Nalini Morzaria-Luna hemnalin.morzarialuna@noaa.gov [contributor]","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve data from the iDigBio specimen data repository. — ridigbio","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"Retrieve data iDigBio specimen data repository.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"about","dir":"Reference","previous_headings":"","what":"About","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"ridigbio provides interface iDigBio data API described : https://www.idigbio.org/wiki/index.php/IDigBio_API. package can retrieve specimen media records iDigBio data repository. iDigBio portal https://portal.idigbio.org/ uses API able retrieve information shown portal. iDigBio contains nearly 30 million data records museum specimens held United States institutions. also holds nearly 5 million images specimens.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"getting-started","dir":"Reference","previous_headings":"","what":"Getting Started","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"main function idig_search_records reviewing documenation first ?idig_search_records recommended.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"limitations","dir":"Reference","previous_headings":"","what":"Limitations","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"package yet provide interface mapping download APIs.","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"citing","dir":"Reference","previous_headings":"","what":"Citing","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"cite ridigbio package work, please use following format: Michonneau F, Collins M, Chamberlain SA (2016). ridigbio: interface iDigBio's search API allows downloading specimen records. R package version 0.3.8. https://github.com/iDigBio/ridigbio","code":""},{"path":"http://idigbio.github.io/ridigbio/reference/ridigbio.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Retrieve data from the iDigBio specimen data repository. — ridigbio","text":"Francois Michonneau francois.michonneau@gmail.com Matthew Collins mcollins@acis.ufl.edu","code":""},{"path":[]},{"path":"http://idigbio.github.io/ridigbio/news/index.html","id":"documentation-0-3-9","dir":"Changelog","previous_headings":"","what":"Documentation","title":"ridigbio 0.3.9","text":"Pkgdown site created!","code":""},{"path":"http://idigbio.github.io/ridigbio/news/index.html","id":"ridigbio-038","dir":"Changelog","previous_headings":"","what":"ridigbio 0.3.8","title":"ridigbio 0.3.8","text":"CRAN release: 2024-01-31","code":""},{"path":"http://idigbio.github.io/ridigbio/news/index.html","id":"new-features-0-3-8","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ridigbio 0.3.8","text":"Default fields returned users updated return research-grade fields. Previously, returned datecollected field default, recommend used scientific research. datecollected? field created data ingestion process. data provider provide full date Darwin Core eventDate field, complete value missing parts (.e., month /day) randomly generated thus may lack real meaning. generated dates difficult detect, randomly distributed. currently working modify ingestion pipeline avoid randomly generating dates. However, dates remain issue across biodiversity aggregators solution clear (see GBIF example). prevent user misuse term, longer providing datecollected field default instead returning following fields: c(“data.dwc:eventDate”, “data.dwc:year”, “data.dwc:month”, “data.dwc:day”). Please advised fields date format. Instead, dates text strings. many ways convert dates, example, see gatoRs remove_duplicate function ridigbio proposed solution .","code":""},{"path":"http://idigbio.github.io/ridigbio/news/index.html","id":"documentation-0-3-8","dir":"Changelog","previous_headings":"","what":"Documentation","title":"ridigbio 0.3.8","text":"Additional function documentation added streamline data use.","code":""}]
